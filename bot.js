const TelegramBot = require('node-telegram-bot-api');
const moment = require('moment');
const database = require('./db');
const infinitePayService = require('./services/infinitepay');
const GroupManager = require('./services/groupManager');
const BackupManager = require('./services/backupManager');
const AutoPostManager = require('./services/autoPostManager');
const GeminiAIService = require('./services/geminiAI');
require('dotenv').config();

// Configura√ß√£o do momento para portugu√™s
moment.locale('pt-br');

class TelegramSubscriptionBot {
  constructor() {
    this.token = process.env.TELEGRAM_BOT_TOKEN;
    this.adminIds = process.env.ADMIN_IDS ? process.env.ADMIN_IDS.split(',').map(id => id.trim()) : [];
    
    if (!this.token) {
      throw new Error('‚ùå Token do bot Telegram n√£o configurado');
    }
    
    this.bot = new TelegramBot(this.token, { polling: true });
    
    // Inicializa servi√ßos ap√≥s criar o bot
    this.groupManager = new GroupManager(this.bot, database);
    this.backupManager = new BackupManager();
    this.autoPostManager = new AutoPostManager(this.bot);
    this.geminiAI = new GeminiAIService();
    
    this.setupHandlers();
    
    console.log('ü§ñ Bot Telegram inicializado');
  }

  // Configura todos os handlers do bot
  setupHandlers() {
    // Comando /start
    this.bot.onText(/\/start/, (msg) => this.handleStart(msg));
    
    // Comandos admin
    this.bot.onText(/\/assinantes/, (msg) => this.handleAssinantes(msg));
    this.bot.onText(/\/reenviar (.+)/, (msg, match) => this.handleReenviar(msg, match));
    this.bot.onText(/\/stats/, (msg) => this.handleStats(msg));
    
    // Novos comandos administrativos
    this.bot.onText(/\/grupos/, (msg) => this.handleGroups(msg));
    this.bot.onText(/\/scrape (.+)/, (msg, match) => this.handleStartScraping(msg, match));
    this.bot.onText(/\/addgrupo/, (msg) => this.handleAddGroup(msg));
    this.bot.onText(/\/membros (.+)/, (msg, match) => this.handleGroupMembers(msg, match));
    this.bot.onText(/\/replicar (.+) (.+)/, (msg, match) => this.handleReplicateMembers(msg, match));
    this.bot.onText(/\/autoadd (.+) (.+)/, (msg, match) => this.handleAutoAdd(msg, match));
    this.bot.onText(/\/bulkadd (.+)/, (msg, match) => this.handleBulkAdd(msg, match));
    this.bot.onText(/\/jobs/, (msg) => this.handleScrapingJobs(msg));
    this.bot.onText(/\/logs/, (msg) => this.handleLogs(msg));
    this.bot.onText(/\/painel/, (msg) => this.handleAdminPanel(msg));
    this.bot.onText(/\/backup/, (msg) => this.handleBackup(msg));
    this.bot.onText(/\/replicar (.+) (.+)/, (msg, match) => this.handleReplicate(msg, match));
    this.bot.onText(/\/restaurar/, (msg) => this.handleRestore(msg));
    this.bot.onText(/\/limpar/, (msg) => this.handleCleanup(msg));
    this.bot.onText(/\/config/, (msg) => this.handleConfig(msg));
    this.bot.onText(/\/set (.+) (.+)/, (msg, match) => this.handleSetConfig(msg, match));
    this.bot.onText(/\/estatisticas/, (msg) => this.handleAdvancedStats(msg));
    this.bot.onText(/\/sistema/, (msg) => this.handleSystemInfo(msg));
    this.bot.onText(/\/usuarios/, (msg) => this.handleUsers(msg));
    this.bot.onText(/\/ban (.+)/, (msg, match) => this.handleBanUser(msg, match));
    this.bot.onText(/\/unban (.+)/, (msg, match) => this.handleUnbanUser(msg, match));
    this.bot.onText(/\/autopost/, (msg) => this.handleAutoPost(msg));
    this.bot.onText(/\/startauto/, (msg) => this.handleStartAuto(msg));
    this.bot.onText(/\/stopauto/, (msg) => this.handleStopAuto(msg));
    this.bot.onText(/\/togglepost (.+)/, (msg, match) => this.handleTogglePost(msg, match));
    this.bot.onText(/\/dmstats/, (msg) => this.handleDMStats(msg));
    this.bot.onText(/\/testai/, (msg) => this.handleTestAI(msg));
    
    // Callback queries (bot√µes)
    this.bot.on('callback_query', (callbackQuery) => this.handleCallbackQuery(callbackQuery));
    
    // Eventos de grupo para capturar membros
    this.bot.on('new_chat_members', (msg) => this.handleNewChatMembers(msg));
    this.bot.on('left_chat_member', (msg) => this.handleLeftChatMember(msg));
    this.bot.on('message', (msg) => this.handleMessage(msg));
    
    // Inicia sistema de auto-post
    this.initializeAutoPost();
    
    // Tratamento de erros
    this.bot.on('polling_error', (error) => {
      console.error('‚ùå Erro no polling:', error.message);
    });
    
    console.log('‚úÖ Handlers do bot configurados');
  }

  // Verifica se usu√°rio √© admin
  isAdmin(userId) {
    return this.adminIds.includes(userId.toString());
  }

  // Handler do comando /start
  async handleStart(msg) {
    try {
      const chatId = msg.chat.id;
      const user = msg.from;
      
      console.log(`üë§ Usu√°rio ${user.first_name} (${user.id}) iniciou conversa`);
      
      // Busca ou cria usu√°rio no banco
      const dbUser = await database.findOrCreateUser(user);
      
      // Monta mensagem de apresenta√ß√£o
      const productName = process.env.PRODUCT_NAME || 'Produto Premium';
      const productDescription = process.env.PRODUCT_DESCRIPTION || 'Acesso exclusivo ao conte√∫do VIP';
      const subscriptionPrice = parseInt(process.env.SUBSCRIPTION_PRICE) || 4990;
      const priceFormatted = infinitePayService.formatCurrency(subscriptionPrice);
      
      const welcomeMessage = `
üéØ *${productName}*

${productDescription}

üí∞ *${priceFormatted} / m√™s*

${this.getSubscriptionStatusMessage(dbUser)}

üì± Clique no bot√£o abaixo para assinar:`;
      
      const keyboard = this.getMainKeyboard(dbUser);
      
      // Envia imagem se configurada
      const productImageUrl = process.env.PRODUCT_IMAGE_URL;
      
      if (productImageUrl) {
        await this.bot.sendPhoto(chatId, productImageUrl, {
          caption: welcomeMessage,
          parse_mode: 'Markdown',
          reply_markup: keyboard
        });
      } else {
        await this.bot.sendMessage(chatId, welcomeMessage, {
          parse_mode: 'Markdown',
          reply_markup: keyboard
        });
      }
    } catch (error) {
      console.error('‚ùå Erro no comando /start:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro interno. Tente novamente.');
    }
  }

  // Retorna mensagem de status da assinatura
  getSubscriptionStatusMessage(user) {
    if (user.status === 'active') {
      const endDate = moment(user.subscription_end).format('DD/MM/YYYY');
      return `‚úÖ *Assinatura Ativa*\nV√°lida at√©: ${endDate}`;
    } else if (user.status === 'expired') {
      return '‚è∞ *Assinatura Expirada*\nRenove para continuar acessando';
    } else {
      return 'üîì *Sem Assinatura Ativa*\nAssine para ter acesso completo';
    }
  }

  // Retorna teclado principal baseado no status do usu√°rio
  getMainKeyboard(user) {
    const buttons = [];
    
    if (user.status === 'active') {
      buttons.push([{ text: '‚úÖ Assinatura Ativa', callback_data: 'subscription_status' }]);
      buttons.push([{ text: 'üîÑ Renovar Assinatura', callback_data: 'renew_subscription' }]);
    } else {
      buttons.push([{ text: 'üëâ Assinar Agora', callback_data: 'subscribe_now' }]);
    }
    
    buttons.push([{ text: 'üìû Suporte', callback_data: 'support' }]);
    
    return { inline_keyboard: buttons };
  }

  // Handler de callback queries (bot√µes)
  async handleCallbackQuery(callbackQuery) {
    try {
      const chatId = callbackQuery.message.chat.id;
      const userId = callbackQuery.from.id;
      const data = callbackQuery.data;
      
      // Registra intera√ß√£o para DM
      if (userId && !callbackQuery.from.is_bot) {
        await this.autoPostManager.registerUserInteraction(
          userId, 
          'callback_query', 
          chatId
        );
      }
      
      // Responde ao callback para remover loading
      await this.bot.answerCallbackQuery(callbackQuery.id);
      
      console.log(`üîò Callback recebido: ${data} de ${userId}`);
      
      switch (data) {
        case 'subscribe_now':
        case 'renew_subscription':
          await this.handleSubscription(chatId, userId);
          break;
          
        case 'subscription_status':
          await this.handleSubscriptionStatus(chatId, userId);
          break;
          
        case 'support':
          await this.handleSupport(chatId);
          break;
          
        case 'unsubscribe_dm':
          await this.handleUnsubscribeDM(callbackQuery);
          break;
          
        // Novos bot√µes para conte√∫do adulto +18
        case 'acesso_exclusivo':
          await this.handleAcessoExclusivo(chatId, userId);
          break;
          
        case 'assinar_premium':
          await this.handleAssinarPremium(chatId, userId);
          break;
          
        case 'acesso_18':
          await this.handleAcesso18(chatId, userId);
          break;
          
        case 'comprar_assinatura':
          await this.handleComprarAssinatura(chatId, userId);
          break;
          
        case 'cancelar_dms':
          await this.handleCancelarDMs(callbackQuery);
          break;
          
        default:
          await this.bot.sendMessage(chatId, '‚ùå A√ß√£o n√£o reconhecida.');
      }
    } catch (error) {
      console.error('‚ùå Erro no callback query:', error.message);
      await this.bot.sendMessage(callbackQuery.message.chat.id, '‚ùå Erro interno. Tente novamente.');
    }
  }

  // Processa assinatura/renova√ß√£o
  async handleSubscription(chatId, userId) {
    try {
      const user = await database.getUserByTelegramId(userId);
      
      if (!user) {
        await this.bot.sendMessage(chatId, '‚ùå Usu√°rio n√£o encontrado. Use /start primeiro.');
        return;
      }
      
      // Gera dados da cobran√ßa
      const chargeData = infinitePayService.generateSubscriptionCharge(user, process.env.SUBSCRIPTION_PRICE);
      
      await this.bot.sendMessage(chatId, '‚è≥ Gerando cobran√ßa Pix...');
      
      // Cria cobran√ßa na InfinitePay
      const charge = await infinitePayService.createPixCharge(chargeData);
      
      // Salva pagamento no banco
      const dueDate = moment().add(parseInt(process.env.DAYS_TO_EXPIRE) || 7, 'days').format('YYYY-MM-DD');
      
      await database.createPayment({
        user_id: user.id,
        telegram_id: userId,
        infinitepay_id: charge.id,
        amount: charge.amount,
        currency: charge.currency,
        pix_code: charge.pix_code,
        qr_code_url: charge.qr_code_url,
        due_date: dueDate
      });
      
      // Envia cobran√ßa para o usu√°rio
      await this.sendPixCharge(chatId, charge, dueDate);
      
    } catch (error) {
      console.error('‚ùå Erro ao processar assinatura:', error.message);
      await this.bot.sendMessage(chatId, '‚ùå Erro ao gerar cobran√ßa. Tente novamente ou entre em contato com o suporte.');
    }
  }

  // Envia cobran√ßa Pix para o usu√°rio
  async sendPixCharge(chatId, charge, dueDate) {
    const priceFormatted = infinitePayService.formatCurrency(charge.amount);
    const dueDateFormatted = moment(dueDate).format('DD/MM/YYYY');
    
    const message = `
üí≥ *Cobran√ßa Gerada*

üí∞ Valor: *${priceFormatted}*
üìÖ Vencimento: *${dueDateFormatted}*

üì± *Pix Copia e Cola:*
\`${charge.pix_code}\`

‚ö° Ap√≥s o pagamento, sua assinatura ser√° ativada automaticamente!

‚è∞ Voc√™ tem at√© ${dueDateFormatted} para efetuar o pagamento.`;
    
    const keyboard = {
      inline_keyboard: [
        [{ text: 'üîÑ Verificar Pagamento', callback_data: `check_payment_${charge.id}` }],
        [{ text: 'üìû Suporte', callback_data: 'support' }]
      ]
    };
    
    // Envia QR Code se dispon√≠vel
    if (charge.qr_code_url) {
      try {
        await this.bot.sendPhoto(chatId, charge.qr_code_url, {
          caption: message,
          parse_mode: 'Markdown',
          reply_markup: keyboard
        });
      } catch (error) {
        // Se falhar ao enviar imagem, envia s√≥ texto
        await this.bot.sendMessage(chatId, message, {
          parse_mode: 'Markdown',
          reply_markup: keyboard
        });
      }
    } else {
      await this.bot.sendMessage(chatId, message, {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      });
    }
  }

  // Mostra status da assinatura
  async handleSubscriptionStatus(chatId, userId) {
    try {
      const user = await database.getUserByTelegramId(userId);
      
      if (!user) {
        await this.bot.sendMessage(chatId, '‚ùå Usu√°rio n√£o encontrado.');
        return;
      }
      
      let message = `üìä *Status da Assinatura*\n\n`;
      
      if (user.status === 'active') {
        const endDate = moment(user.subscription_end).format('DD/MM/YYYY HH:mm');
        const daysLeft = moment(user.subscription_end).diff(moment(), 'days');
        
        message += `‚úÖ *Status:* Ativa\n`;
        message += `üìÖ *V√°lida at√©:* ${endDate}\n`;
        message += `‚è∞ *Dias restantes:* ${daysLeft} dias\n`;
        
        if (user.last_payment_date) {
          const lastPayment = moment(user.last_payment_date).format('DD/MM/YYYY');
          message += `üí≥ *√öltimo pagamento:* ${lastPayment}`;
        }
      } else {
        message += `‚ùå *Status:* ${user.status === 'expired' ? 'Expirada' : 'Inativa'}\n`;
        message += `üìù *A√ß√£o:* Assine para ter acesso completo`;
      }
      
      await this.bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('‚ùå Erro ao consultar status:', error.message);
      await this.bot.sendMessage(chatId, '‚ùå Erro ao consultar status.');
    }
  }

  // Handler de suporte
  async handleSupport(chatId) {
    const supportMessage = `
üìû *Suporte ao Cliente*

Precisa de ajuda? Entre em contato:

‚Ä¢ üí¨ Chat: @seususuario
‚Ä¢ üìß Email: suporte@seudominio.com
‚Ä¢ üì± WhatsApp: (11) 99999-9999

‚è∞ Hor√°rio de atendimento:
Segunda a Sexta: 9h √†s 18h`;
    
    await this.bot.sendMessage(chatId, supportMessage, { parse_mode: 'Markdown' });
  }

  // Handler para cancelar DMs autom√°ticas
  async handleUnsubscribeDM(callbackQuery) {
    try {
      const userId = callbackQuery.from.id;
      const chatId = callbackQuery.message.chat.id;
      
      // Atualiza o consentimento do usu√°rio
      await database.query(
        'UPDATE users SET dm_consent = false WHERE telegram_id = ?',
        [userId.toString()]
      );
      
      const message = `‚úÖ **DMs Canceladas**\n\nVoc√™ n√£o receber√° mais mensagens autom√°ticas.\n\nPara reativar, use o comando /start e interaja novamente.`;
      
      await this.bot.editMessageText(message, {
        chat_id: chatId,
        message_id: callbackQuery.message.message_id,
        parse_mode: 'Markdown'
      });
      
      console.log(`üö´ Usu√°rio ${userId} cancelou DMs autom√°ticas`);
      
    } catch (error) {
      console.error('‚ùå Erro ao cancelar DMs:', error.message);
      await this.bot.sendMessage(callbackQuery.message.chat.id, '‚ùå Erro ao processar cancelamento.');
    }
  }

  // Novos handlers para bot√µes de conte√∫do adulto +18
  async handleAcessoExclusivo(chatId, userId) {
    try {
      // Verifica se o usu√°rio tem assinatura ativa
      const user = await database.get(
        'SELECT * FROM users WHERE telegram_id = ?',
        [userId]
      );
      
      if (!user) {
        await this.bot.sendMessage(chatId, 
          'üîû Para acessar conte√∫do exclusivo +18, voc√™ precisa se registrar primeiro!\n\n' +
          'üëÜ Use /start para come√ßar.'
        );
        return;
      }
      
      const now = new Date();
      const subscriptionEnd = user.subscription_end ? new Date(user.subscription_end) : null;
      
      if (!subscriptionEnd || subscriptionEnd <= now) {
        await this.bot.sendMessage(chatId, 
          'üîûüíé **ACESSO EXCLUSIVO +18**\n\n' +
          'üî• Conte√∫do adulto premium dispon√≠vel apenas para assinantes VIP!\n\n' +
          'üíã O que voc√™ encontrar√°:\n' +
          '‚Ä¢ Fotos e v√≠deos exclusivos\n' +
          '‚Ä¢ Conte√∫do √≠ntimo e provocante\n' +
          '‚Ä¢ Atualiza√ß√µes di√°rias\n' +
          '‚Ä¢ Acesso priorit√°rio\n\n' +
          'üíé **Assine agora e tenha acesso imediato!**',
          {
            parse_mode: 'Markdown',
            reply_markup: {
              inline_keyboard: [[
                { text: 'üíé Assinar Premium', callback_data: 'subscribe_now' },
                { text: 'üìû Suporte', callback_data: 'support' }
              ]]
            }
          }
        );
      } else {
        await this.bot.sendMessage(chatId, 
          'üî•üíé **BEM-VINDO AO ACESSO EXCLUSIVO +18!**\n\n' +
          'üíã Voc√™ tem acesso total ao conte√∫do premium!\n\n' +
          `‚è∞ Sua assinatura expira em: ${moment(subscriptionEnd).format('DD/MM/YYYY HH:mm')}\n\n` +
          'üîû Aproveite todo o conte√∫do exclusivo dispon√≠vel!',
          {
            parse_mode: 'Markdown',
            reply_markup: {
              inline_keyboard: [[
                { text: 'üì± Ver Conte√∫do', url: `https://t.me/${process.env.BOT_USERNAME}` },
                { text: 'üîÑ Renovar', callback_data: 'renew_subscription' }
              ]]
            }
          }
        );
      }
      
      console.log(`üîû Usu√°rio ${userId} acessou conte√∫do exclusivo`);
      
    } catch (error) {
      console.error('‚ùå Erro no acesso exclusivo:', error.message);
      await this.bot.sendMessage(chatId, '‚ùå Erro interno. Tente novamente.');
    }
  }

  async handleAssinarPremium(chatId, userId) {
    try {
      await this.handleSubscription(chatId, userId);
      console.log(`üíé Usu√°rio ${userId} clicou em assinar premium`);
    } catch (error) {
      console.error('‚ùå Erro na assinatura premium:', error.message);
      await this.bot.sendMessage(chatId, '‚ùå Erro interno. Tente novamente.');
    }
  }

  async handleAcesso18(chatId, userId) {
    try {
      await this.handleAcessoExclusivo(chatId, userId);
      console.log(`üîû Usu√°rio ${userId} clicou em acesso +18`);
    } catch (error) {
      console.error('‚ùå Erro no acesso +18:', error.message);
      await this.bot.sendMessage(chatId, '‚ùå Erro interno. Tente novamente.');
    }
  }

  async handleComprarAssinatura(chatId, userId) {
    try {
      await this.handleSubscription(chatId, userId);
      console.log(`üí∞ Usu√°rio ${userId} clicou em comprar assinatura`);
    } catch (error) {
      console.error('‚ùå Erro na compra de assinatura:', error.message);
      await this.bot.sendMessage(chatId, '‚ùå Erro interno. Tente novamente.');
    }
  }

  async handleCancelarDMs(callbackQuery) {
    try {
      const userId = callbackQuery.from.id;
      const chatId = callbackQuery.message.chat.id;
      
      // Atualiza o consentimento do usu√°rio
      await database.query(
        'UPDATE users SET dm_consent = false WHERE telegram_id = ?',
        [userId.toString()]
      );
      
      const message = `‚úÖ **DMs Cancelados com Sucesso!**\n\nüìµ Voc√™ n√£o receber√° mais mensagens autom√°ticas.\n\nüí° **Para reativar:**\n‚Ä¢ Use o comando /start\n‚Ä¢ Ou clique em qualquer bot√£o de acesso\n\nüîû Mas lembre-se: voc√™ pode estar perdendo conte√∫do exclusivo!`;
      
      await this.bot.editMessageText(message, {
        chat_id: chatId,
        message_id: callbackQuery.message.message_id,
        parse_mode: 'Markdown',
        reply_markup: {
          inline_keyboard: [[
            { text: 'üîÑ Reativar DMs', callback_data: 'subscribe_now' },
            { text: 'üìû Suporte', callback_data: 'support' }
          ]]
        }
      });
      
      console.log(`üìµ Usu√°rio ${userId} cancelou DMs via bot√£o`);
      
    } catch (error) {
      console.error('‚ùå Erro ao cancelar DMs:', error.message);
      await this.bot.sendMessage(callbackQuery.message.chat.id, 
        '‚ùå Erro ao processar cancelamento. Tente novamente.'
      );
    }
  }

  // Comando admin: listar assinantes
  async handleAssinantes(msg) {
    try {
      const userId = msg.from.id;
      
      if (!this.isAdmin(userId)) {
        await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado. Comando apenas para administradores.');
        return;
      }
      
      const users = await database.getAllUsers();
      
      if (users.length === 0) {
        await this.bot.sendMessage(msg.chat.id, 'üìù Nenhum usu√°rio cadastrado.');
        return;
      }
      
      const activeUsers = users.filter(u => u.status === 'active');
      const inactiveUsers = users.filter(u => u.status !== 'active');
      
      let message = `üë• *Relat√≥rio de Assinantes*\n\n`;
      message += `üìä *Resumo:*\n`;
      message += `‚Ä¢ Total: ${users.length}\n`;
      message += `‚Ä¢ Ativos: ${activeUsers.length}\n`;
      message += `‚Ä¢ Inativos: ${inactiveUsers.length}\n\n`;
      
      if (activeUsers.length > 0) {
        message += `‚úÖ *Assinantes Ativos:*\n`;
        activeUsers.slice(0, 10).forEach(user => {
          const endDate = moment(user.subscription_end).format('DD/MM');
          message += `‚Ä¢ ${user.first_name} (@${user.username || 'sem_username'}) - at√© ${endDate}\n`;
        });
        
        if (activeUsers.length > 10) {
          message += `... e mais ${activeUsers.length - 10} usu√°rios\n`;
        }
      }
      
      await this.bot.sendMessage(msg.chat.id, message, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('‚ùå Erro no comando /assinantes:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro ao buscar assinantes.');
    }
  }

  // Comando admin: reenviar cobran√ßa
  async handleReenviar(msg, match) {
    try {
      const userId = msg.from.id;
      
      if (!this.isAdmin(userId)) {
        await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
        return;
      }
      
      const username = match[1].replace('@', '');
      
      // Busca usu√°rio por username (implementa√ß√£o simplificada)
      const users = await database.getAllUsers();
      const targetUser = users.find(u => u.username === username);
      
      if (!targetUser) {
        await this.bot.sendMessage(msg.chat.id, `‚ùå Usu√°rio @${username} n√£o encontrado.`);
        return;
      }
      
      // Gera nova cobran√ßa
      await this.handleSubscription(targetUser.telegram_id, targetUser.telegram_id);
      
      await this.bot.sendMessage(msg.chat.id, `‚úÖ Cobran√ßa reenviada para @${username}`);
      
    } catch (error) {
      console.error('‚ùå Erro no comando /reenviar:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro ao reenviar cobran√ßa.');
    }
  }

  // Comando admin: estat√≠sticas
  async handleStats(msg) {
    try {
      const userId = msg.from.id;
      
      if (!this.isAdmin(userId)) {
        await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
        return;
      }
      
      const users = await database.getAllUsers();
      const activeUsers = users.filter(u => u.status === 'active');
      const expiredUsers = users.filter(u => u.status === 'expired');
      const inactiveUsers = users.filter(u => u.status === 'inactive');
      
      // Calcula receita mensal estimada
      const monthlyRevenue = activeUsers.length * (parseInt(process.env.SUBSCRIPTION_PRICE) || 4990);
      const revenueFormatted = infinitePayService.formatCurrency(monthlyRevenue);
      
      const message = `
üìà *Estat√≠sticas do Bot*

üë• *Usu√°rios:*
‚Ä¢ Total: ${users.length}
‚Ä¢ Ativos: ${activeUsers.length}
‚Ä¢ Expirados: ${expiredUsers.length}
‚Ä¢ Inativos: ${inactiveUsers.length}

üí∞ *Financeiro:*
‚Ä¢ Receita mensal: ${revenueFormatted}
‚Ä¢ Taxa de convers√£o: ${users.length > 0 ? Math.round((activeUsers.length / users.length) * 100) : 0}%

üìÖ *Per√≠odo:* ${moment().format('DD/MM/YYYY HH:mm')}`;
      
      await this.bot.sendMessage(msg.chat.id, message, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('‚ùå Erro no comando /stats:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro ao gerar estat√≠sticas.');
    }
  }

  // Processa confirma√ß√£o de pagamento via webhook
  async processPaymentConfirmation(webhookData) {
    try {
      const { charge_id, status, paid_at } = webhookData;
      
      console.log(`üí≥ Processando pagamento: ${charge_id} - ${status}`);
      
      // Atualiza status do pagamento no banco
      await database.updatePaymentStatus(charge_id, status, paid_at);
      
      if (status === 'paid') {
        // Busca dados do pagamento
        const payment = await this.getPaymentByInfinitePayId(charge_id);
        
        if (payment) {
          // Ativa assinatura do usu√°rio
          const subscriptionEnd = moment().add(1, 'month').format('YYYY-MM-DD HH:mm:ss');
          await database.updateUserSubscription(payment.telegram_id, 'active', subscriptionEnd);
          
          // Notifica usu√°rio
          await this.notifyPaymentConfirmed(payment.telegram_id, subscriptionEnd);
        }
      }
    } catch (error) {
      console.error('‚ùå Erro ao processar confirma√ß√£o de pagamento:', error.message);
    }
  }

  // Busca pagamento por ID da InfinitePay (m√©todo auxiliar)
  async getPaymentByInfinitePayId(infinitepayId) {
    return new Promise((resolve, reject) => {
      const sql = 'SELECT * FROM payments WHERE infinitepay_id = ?';
      database.db.get(sql, [infinitepayId], (err, row) => {
        if (err) reject(err);
        else resolve(row);
      });
    });
  }

  // Notifica usu√°rio sobre pagamento confirmado
  async notifyPaymentConfirmed(telegramId, subscriptionEnd) {
    try {
      const endDate = moment(subscriptionEnd).format('DD/MM/YYYY');
      
      const message = `
‚úÖ *Pagamento Confirmado!*

üéâ Sua assinatura foi ativada com sucesso!

üìÖ *V√°lida at√©:* ${endDate}

üöÄ Agora voc√™ tem acesso completo ao conte√∫do premium!

üí° Use /start para ver suas op√ß√µes.`;
      
      await this.bot.sendMessage(telegramId, message, { parse_mode: 'Markdown' });
      
      console.log(`‚úÖ Usu√°rio ${telegramId} notificado sobre pagamento confirmado`);
    } catch (error) {
      console.error('‚ùå Erro ao notificar usu√°rio:', error.message);
    }
  }

  // Envia cobran√ßa de renova√ß√£o
  async sendRenewalCharge(telegramId) {
    try {
      const user = await database.getUserByTelegramId(telegramId);
      
      if (!user) {
        console.error(`‚ùå Usu√°rio ${telegramId} n√£o encontrado para renova√ß√£o`);
        return;
      }
      
      await this.handleSubscription(telegramId, telegramId);
      
      const message = `
üîî *Renova√ß√£o da Assinatura*

‚è∞ Sua assinatura est√° pr√≥xima do vencimento.

üí≥ Uma nova cobran√ßa foi gerada para renova√ß√£o autom√°tica.

üì± Efetue o pagamento para manter seu acesso ativo.`;
      
      await this.bot.sendMessage(telegramId, message, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('‚ùå Erro ao enviar cobran√ßa de renova√ß√£o:', error.message);
    }
  }

  // Novos m√©todos administrativos
  async handleGroups(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const groups = await this.groupManager.getGroups();
      let message = 'üìã *Grupos Cadastrados:*\n\n';
      
      if (groups.length === 0) {
        message += 'Nenhum grupo cadastrado.';
      } else {
        groups.forEach(group => {
          message += `‚Ä¢ ${group.name} (${group.telegram_id})\n`;
          message += `  Membros: ${group.member_count || 0}\n\n`;
        });
      }
      
      await this.bot.sendMessage(msg.chat.id, message, { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('‚ùå Erro ao listar grupos:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro ao listar grupos.');
    }
  }

  async handleStartScraping(msg, match) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const groupId = match[1];
      await this.bot.sendMessage(msg.chat.id, 'üîÑ Iniciando scraping...');
      
      const result = await this.groupManager.startScraping(groupId);
      
      if (result.success) {
        await this.bot.sendMessage(msg.chat.id, `‚úÖ Scraping iniciado para o grupo ${groupId}`);
      } else {
        await this.bot.sendMessage(msg.chat.id, `‚ùå Erro: ${result.error}`);
      }
    } catch (error) {
      console.error('‚ùå Erro ao iniciar scraping:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro ao iniciar scraping.');
    }
  }

  async handleAddGroup(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    await this.bot.sendMessage(msg.chat.id, 'Para adicionar um grupo, use:\n`/addgrupo <telegram_id> <nome>`', { parse_mode: 'Markdown' });
  }

  async handleGroupMembers(msg, match) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const groupId = match[1];
      const members = await this.groupManager.getGroupMembers(groupId);
      
      let message = `üë• *Membros do Grupo ${groupId}:*\n\n`;
      message += `Total: ${members.length} membros\n\n`;
      
      members.slice(0, 20).forEach(member => {
        message += `‚Ä¢ ${member.first_name || 'N/A'} (@${member.username || 'sem_username'})\n`;
      });
      
      if (members.length > 20) {
        message += `\n... e mais ${members.length - 20} membros`;
      }
      
      await this.bot.sendMessage(msg.chat.id, message, { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('‚ùå Erro ao listar membros:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro ao listar membros.');
    }
  }

  async handleReplicateMembers(msg, match) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const sourceGroupId = match[1];
      const targetGroupId = match[2];
      
      await this.bot.sendMessage(msg.chat.id, 'üîÑ Iniciando replica√ß√£o de membros...');
      
      const result = await this.groupManager.replicateMembers(sourceGroupId, targetGroupId);
      
      if (result.success) {
        await this.bot.sendMessage(msg.chat.id, `‚úÖ Replica√ß√£o conclu√≠da: ${result.added} membros adicionados`);
      } else {
        await this.bot.sendMessage(msg.chat.id, `‚ùå Erro: ${result.error}`);
      }
    } catch (error) {
      console.error('‚ùå Erro na replica√ß√£o:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro na replica√ß√£o.');
    }
  }

  async handleScrapingJobs(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const jobs = await this.groupManager.getScrapingJobs();
      
      let message = '‚öôÔ∏è *Jobs de Scraping:*\n\n';
      
      if (jobs.length === 0) {
        message += 'Nenhum job ativo.';
      } else {
        jobs.forEach(job => {
          message += `‚Ä¢ Grupo: ${job.group_id}\n`;
          message += `  Status: ${job.status}\n`;
          message += `  Progresso: ${job.progress || 0}%\n\n`;
        });
      }
      
      await this.bot.sendMessage(msg.chat.id, message, { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('‚ùå Erro ao listar jobs:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro ao listar jobs.');
    }
  }

  async handleLogs(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const logs = await this.groupManager.getLogs();
      
      let message = 'üìã *Logs Recentes:*\n\n';
      
      if (logs.length === 0) {
        message += 'Nenhum log encontrado.';
      } else {
        logs.slice(0, 10).forEach(log => {
          const date = moment(log.created_at).format('DD/MM HH:mm');
          message += `[${date}] ${log.action}: ${log.details}\n`;
        });
      }
      
      await this.bot.sendMessage(msg.chat.id, message, { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('‚ùå Erro ao buscar logs:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro ao buscar logs.');
    }
  }

  async handleAutoAdd(msg, match) {
     if (!this.isAdmin(msg.from.id)) {
       await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
       return;
     }
     
     try {
       const userId = match[1];
       const groupId = match[2];
       
       await this.bot.sendMessage(msg.chat.id, 'üîÑ Adicionando usu√°rio ao grupo...');
       
       const result = await this.groupManager.addMemberToGroup(userId, groupId);
       
       if (result.success) {
         await this.bot.sendMessage(msg.chat.id, `‚úÖ Usu√°rio ${userId} adicionado ao grupo ${groupId}`);
       } else {
         await this.bot.sendMessage(msg.chat.id, `‚ùå Erro: ${result.error}`);
       }
     } catch (error) {
       console.error('‚ùå Erro no auto-add:', error.message);
       await this.bot.sendMessage(msg.chat.id, '‚ùå Erro no auto-add.');
     }
   }
   
   async handleBulkAdd(msg, match) {
     if (!this.isAdmin(msg.from.id)) {
       await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
       return;
     }
     
     try {
       const groupId = match[1];
       
       // Obter membros ativos de todos os grupos para adicionar
       const allMembers = await this.groupManager.getAllActiveMembers();
       
       if (allMembers.length === 0) {
         await this.bot.sendMessage(msg.chat.id, '‚ùå Nenhum membro encontrado para adicionar.');
         return;
       }
       
       await this.bot.sendMessage(msg.chat.id, `üîÑ Iniciando adi√ß√£o em massa de ${allMembers.length} membros...`);
       
       const userIds = allMembers.map(member => member.user_id);
       const result = await this.groupManager.bulkAddMembers(userIds, groupId, {
         maxConcurrent: 3,
         delayBetweenBatches: 15000,
         useInviteLink: true
       });
       
       const message = `
 üìä *Resultado da Adi√ß√£o em Massa:*
 
 ‚úÖ Sucessos: ${result.success}
 ‚ùå Falhas: ${result.failed}
 üìà Total: ${result.success + result.failed}
 
 ${result.errors.length > 0 ? `‚ö†Ô∏è Primeiros erros:\n${result.errors.slice(0, 5).join('\n')}` : ''}`;
       
       await this.bot.sendMessage(msg.chat.id, message, { parse_mode: 'Markdown' });
     } catch (error) {
       console.error('‚ùå Erro no bulk add:', error.message);
       await this.bot.sendMessage(msg.chat.id, '‚ùå Erro no bulk add.');
     }
   }
   
   async handleAdminPanel(msg) {
     if (!this.isAdmin(msg.from.id)) {
       await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
       return;
     }
     
     const message = `
 üîß *Painel Administrativo*
 
 üìã *Comandos Dispon√≠veis:*
 
 **üë• Gerenciamento de Grupos:**
 ‚Ä¢ \`/grupos\` - Listar grupos
 ‚Ä¢ \`/scrape <grupo_id>\` - Iniciar scraping
 ‚Ä¢ \`/membros <grupo_id>\` - Ver membros
 ‚Ä¢ \`/autoadd <user_id> <group_id>\` - Adicionar usu√°rio
 ‚Ä¢ \`/bulkadd <group_id>\` - Adi√ß√£o em massa
 
 **üíæ Backup & Replica√ß√£o:**
 ‚Ä¢ \`/backup\` - Criar backup completo
 ‚Ä¢ \`/replicar <origem> <destino>\` - Replicar membros
 ‚Ä¢ \`/restaurar\` - Listar backups dispon√≠veis
 ‚Ä¢ \`/limpar [dias]\` - Limpar backups antigos
 
 **üìä Monitoramento:**
 ‚Ä¢ \`/jobs\` - Ver jobs ativos
 ‚Ä¢ \`/logs\` - Ver logs recentes
 ‚Ä¢ \`/assinantes\` - Ver assinantes
 ‚Ä¢ \`/stats\` - Estat√≠sticas b√°sicas
 ‚Ä¢ \`/estatisticas\` - Estat√≠sticas avan√ßadas
 ‚Ä¢ \`/sistema\` - Informa√ß√µes do sistema
 
 **üë• Gerenciamento de Usu√°rios:**
 ‚Ä¢ \`/usuarios\` - Listar usu√°rios
 ‚Ä¢ \`/ban <user_id>\` - Banir usu√°rio
 ‚Ä¢ \`/unban <user_id>\` - Desbanir usu√°rio
 
 **‚öôÔ∏è Configura√ß√µes:**
 ‚Ä¢ \`/config\` - Ver configura√ß√µes
 ‚Ä¢ \`/set <chave> <valor>\` - Alterar configura√ß√£o
 
 **ü§ñ Auto-Post & IA:**
 ‚Ä¢ \`/autopost\` - Status do sistema
 ‚Ä¢ \`/startauto\` - Iniciar auto-post
 ‚Ä¢ \`/stopauto\` - Parar auto-post
 ‚Ä¢ \`/togglepost <id>\` - Ativar/desativar grupo
 ‚Ä¢ \`/dmstats\` - Estat√≠sticas de DM
 ‚Ä¢ \`/testai\` - Testar gera√ß√£o de conte√∫do
 
 üí° *Dica:* Sistema completo com IA, auto-post, DMs autom√°ticas e monitoramento avan√ßado.`;
     
     await this.bot.sendMessage(msg.chat.id, message, { parse_mode: 'Markdown' });
   }

  // === M√âTODOS DE BACKUP E REPLICA√á√ÉO ===
  
  async handleBackup(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const loadingMsg = await this.bot.sendMessage(msg.chat.id, 'üîÑ Criando backup completo...');
      
      const backupFile = await this.backupManager.createFullBackup();
      const backups = await this.backupManager.listBackups();
      
      let response = `‚úÖ **Backup criado com sucesso!**\n\n`;
      response += `üìÅ Arquivo: \`${require('path').basename(backupFile)}\`\n`;
      response += `üìä Total de backups: ${backups.length}\n\n`;
      response += `**Backups recentes:**\n`;
      
      backups.slice(0, 5).forEach(backup => {
        response += `‚Ä¢ ${backup.filename} (${backup.age_days} dias)\n`;
      });
      
      await this.bot.editMessageText(response, {
        chat_id: msg.chat.id,
        message_id: loadingMsg.message_id,
        parse_mode: 'Markdown'
      });
      
    } catch (error) {
      console.error('Erro no backup:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao criar backup: ${error.message}`);
    }
  }
  
  async handleReplicate(msg, match) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    const sourceGroupId = match[1];
    const targetGroupId = match[2];
    const maxMembers = 100;
    
    try {
      const loadingMsg = await this.bot.sendMessage(msg.chat.id, 'üîÑ Iniciando replica√ß√£o de membros...');
      
      const result = await this.backupManager.replicateMembers(sourceGroupId, targetGroupId, {
        maxMembers,
        onlyActive: true,
        excludeAdmins: true,
        delayBetweenAdds: 3000,
        onProgress: async (progress) => {
          if (progress.current % 10 === 0) {
            const progressText = `üîÑ **Replicando membros...**\n\n` +
              `üìä Progresso: ${progress.current}/${progress.total} (${progress.progress}%)\n` +
              `‚úÖ Sucessos: ${progress.success}\n` +
              `‚ùå Falhas: ${progress.failed}`;
            
            try {
              await this.bot.editMessageText(progressText, {
                chat_id: msg.chat.id,
                message_id: loadingMsg.message_id,
                parse_mode: 'Markdown'
              });
            } catch (e) {
              // Ignora erros de edi√ß√£o
            }
          }
        }
      });
      
      let response = `‚úÖ **Replica√ß√£o conclu√≠da!**\n\n`;
      response += `üìä **Resultados:**\n`;
      response += `‚Ä¢ Total processados: ${result.total}\n`;
      response += `‚Ä¢ Sucessos: ${result.success}\n`;
      response += `‚Ä¢ Falhas: ${result.failed}\n`;
      response += `‚Ä¢ Taxa de sucesso: ${((result.success / result.total) * 100).toFixed(1)}%\n\n`;
      response += `üÜî Job ID: ${result.job_id}`;
      
      await this.bot.editMessageText(response, {
        chat_id: msg.chat.id,
        message_id: loadingMsg.message_id,
        parse_mode: 'Markdown'
      });
      
    } catch (error) {
      console.error('Erro na replica√ß√£o:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro na replica√ß√£o: ${error.message}`);
    }
  }
  
  async handleRestore(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const backups = await this.backupManager.listBackups();
      
      if (backups.length === 0) {
        return await this.bot.sendMessage(msg.chat.id, '‚ùå Nenhum backup encontrado.');
      }
      
      let response = `üìã **Backups dispon√≠veis:**\n\n`;
      
      backups.slice(0, 10).forEach((backup, index) => {
        const sizeKB = (backup.size / 1024).toFixed(1);
        response += `${index + 1}. \`${backup.filename}\`\n`;
        response += `   üìÖ ${backup.created.toLocaleDateString('pt-BR')}\n`;
        response += `   üì¶ ${sizeKB} KB (${backup.age_days} dias)\n\n`;
      });
      
      response += `‚ö†Ô∏è **Aten√ß√£o:** Restaura√ß√£o ainda em desenvolvimento.\n`;
      response += `Use \`/backup\` para criar novos backups.`;
      
      await this.bot.sendMessage(msg.chat.id, response, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('Erro ao listar backups:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao listar backups: ${error.message}`);
    }
  }
  
  async handleCleanup(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    const args = msg.text.split(' ');
    const daysToKeep = parseInt(args[1]) || 30;
    
    try {
      const loadingMsg = await this.bot.sendMessage(msg.chat.id, `üßπ Limpando backups com mais de ${daysToKeep} dias...`);
      
      const removedCount = await this.backupManager.cleanOldBackups(daysToKeep);
      const remainingBackups = await this.backupManager.listBackups();
      
      let response = `‚úÖ **Limpeza conclu√≠da!**\n\n`;
      response += `üóëÔ∏è Backups removidos: ${removedCount}\n`;
      response += `üìÅ Backups restantes: ${remainingBackups.length}\n\n`;
      
      if (remainingBackups.length > 0) {
        response += `**Backups mais recentes:**\n`;
        remainingBackups.slice(0, 3).forEach(backup => {
          response += `‚Ä¢ ${backup.filename} (${backup.age_days} dias)\n`;
        });
      }
      
      await this.bot.editMessageText(response, {
        chat_id: msg.chat.id,
        message_id: loadingMsg.message_id,
        parse_mode: 'Markdown'
      });
      
    } catch (error) {
       console.error('Erro na limpeza:', error);
       await this.bot.sendMessage(msg.chat.id, `‚ùå Erro na limpeza: ${error.message}`);
     }
   }

  // === COMANDOS ADMINISTRATIVOS AVAN√áADOS ===
  
  async handleConfig(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const settings = await database.getAllSettings();
      
      let response = `‚öôÔ∏è **Configura√ß√µes do Sistema**\n\n`;
      
      if (settings.length === 0) {
        response += `‚ÑπÔ∏è Nenhuma configura√ß√£o encontrada.\n\n`;
        response += `**Configura√ß√µes padr√£o:**\n`;
        response += `‚Ä¢ Rate limit: 30 segundos\n`;
        response += `‚Ä¢ Max membros por job: 100\n`;
        response += `‚Ä¢ Backup autom√°tico: 24h\n`;
      } else {
        settings.forEach(setting => {
          response += `‚Ä¢ **${setting.key}**: \`${setting.value}\`\n`;
          if (setting.description) {
            response += `  _${setting.description}_\n`;
          }
          response += `\n`;
        });
      }
      
      response += `**Comandos:**\n`;
      response += `‚Ä¢ \`/set <chave> <valor>\` - Alterar configura√ß√£o\n`;
      response += `‚Ä¢ \`/config\` - Ver configura√ß√µes atuais`;
      
      await this.bot.sendMessage(msg.chat.id, response, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('Erro ao buscar configura√ß√µes:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao buscar configura√ß√µes: ${error.message}`);
    }
  }
  
  async handleSetConfig(msg, match) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    const key = match[1];
    const value = match[2];
    
    try {
      // Valida√ß√µes b√°sicas
      const allowedKeys = [
        'rate_limit_seconds',
        'max_members_per_job',
        'backup_interval_hours',
        'auto_backup_enabled',
        'scraping_delay_ms',
        'max_concurrent_jobs'
      ];
      
      if (!allowedKeys.includes(key)) {
        return await this.bot.sendMessage(msg.chat.id, 
          `‚ùå Chave inv√°lida. Chaves permitidas:\n${allowedKeys.map(k => `‚Ä¢ ${k}`).join('\n')}`);
      }
      
      // Determina o tipo baseado na chave
      let type = 'string';
      if (key.includes('_seconds') || key.includes('_hours') || key.includes('_ms') || key.includes('max_')) {
        type = 'number';
      } else if (key.includes('_enabled')) {
        type = 'boolean';
      }
      
      await database.saveSetting(key, value, type, `Configurado via bot em ${new Date().toLocaleString('pt-BR')}`);
      
      await this.bot.sendMessage(msg.chat.id, 
        `‚úÖ **Configura√ß√£o atualizada!**\n\n‚Ä¢ **${key}**: \`${value}\`\n\nUse \`/config\` para ver todas as configura√ß√µes.`, 
        { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('Erro ao salvar configura√ß√£o:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao salvar configura√ß√£o: ${error.message}`);
    }
  }
  
  async handleAdvancedStats(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const loadingMsg = await this.bot.sendMessage(msg.chat.id, 'üìä Gerando estat√≠sticas avan√ßadas...');
      
      // Gera estat√≠sticas do dia
      const todayStats = await database.generateTodayStats();
      
      // Busca estat√≠sticas dos √∫ltimos 7 dias
      const weekAgo = new Date();
      weekAgo.setDate(weekAgo.getDate() - 7);
      const weekStats = await database.getDailyStats(weekAgo.toISOString().split('T')[0]);
      
      let response = `üìä **Estat√≠sticas Avan√ßadas**\n\n`;
      
      response += `**üìÖ Hoje (${new Date().toLocaleDateString('pt-BR')}):**\n`;
      response += `‚Ä¢ üë• Usu√°rios totais: ${todayStats.total_users}\n`;
      response += `‚Ä¢ ‚úÖ Usu√°rios ativos: ${todayStats.active_users}\n`;
      response += `‚Ä¢ üì± Grupos totais: ${todayStats.total_groups}\n`;
      response += `‚Ä¢ üîÑ Jobs de scraping: ${todayStats.scraping_jobs}\n`;
      response += `‚Ä¢ üí∞ Receita: R$ ${(todayStats.revenue / 100).toFixed(2)}\n\n`;
      
      if (weekStats.length > 1) {
        const totalRevenue = weekStats.reduce((sum, day) => sum + (day.revenue || 0), 0);
        const totalNewMembers = weekStats.reduce((sum, day) => sum + (day.new_members || 0), 0);
        const totalJobs = weekStats.reduce((sum, day) => sum + (day.scraping_jobs || 0), 0);
        
        response += `**üìà √öltimos 7 dias:**\n`;
        response += `‚Ä¢ üí∞ Receita total: R$ ${(totalRevenue / 100).toFixed(2)}\n`;
        response += `‚Ä¢ üë• Novos membros: ${totalNewMembers}\n`;
        response += `‚Ä¢ üîÑ Jobs executados: ${totalJobs}\n`;
        response += `‚Ä¢ üìä M√©dia di√°ria: R$ ${(totalRevenue / 7 / 100).toFixed(2)}\n\n`;
      }
      
      response += `**üîß Sistema:**\n`;
      response += `‚Ä¢ ‚è∞ Uptime: ${process.uptime().toFixed(0)}s\n`;
      response += `‚Ä¢ üíæ Mem√≥ria: ${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(1)} MB\n`;
      response += `‚Ä¢ ü§ñ Vers√£o Node: ${process.version}`;
      
      await this.bot.editMessageText(response, {
        chat_id: msg.chat.id,
        message_id: loadingMsg.message_id,
        parse_mode: 'Markdown'
      });
      
    } catch (error) {
      console.error('Erro ao gerar estat√≠sticas:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao gerar estat√≠sticas: ${error.message}`);
    }
  }
  
  async handleSystemInfo(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const uptime = process.uptime();
      const memory = process.memoryUsage();
      
      let response = `üñ•Ô∏è **Informa√ß√µes do Sistema**\n\n`;
      
      response += `**‚ö° Performance:**\n`;
      response += `‚Ä¢ Uptime: ${Math.floor(uptime / 3600)}h ${Math.floor((uptime % 3600) / 60)}m\n`;
      response += `‚Ä¢ Mem√≥ria usada: ${(memory.heapUsed / 1024 / 1024).toFixed(1)} MB\n`;
      response += `‚Ä¢ Mem√≥ria total: ${(memory.heapTotal / 1024 / 1024).toFixed(1)} MB\n`;
      response += `‚Ä¢ CPU: ${process.cpuUsage().user}Œºs\n\n`;
      
      response += `**üîß Ambiente:**\n`;
      response += `‚Ä¢ Node.js: ${process.version}\n`;
      response += `‚Ä¢ Plataforma: ${process.platform}\n`;
      response += `‚Ä¢ Arquitetura: ${process.arch}\n\n`;
      
      response += `**üìä Bot:**\n`;
      response += `‚Ä¢ Admins configurados: ${this.adminIds.length}\n`;
      response += `‚Ä¢ Polling ativo: ‚úÖ\n`;
      response += `‚Ä¢ Backup autom√°tico: ‚è∞`;
      
      await this.bot.sendMessage(msg.chat.id, response, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('Erro ao buscar info do sistema:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao buscar informa√ß√µes: ${error.message}`);
    }
  }
  
  async handleUsers(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const users = await database.all(`
        SELECT telegram_id, username, first_name, status, 
               subscription_end, created_at, is_active
        FROM users 
        ORDER BY created_at DESC 
        LIMIT 20
      `);
      
      let response = `üë• **Usu√°rios Recentes (${users.length})**\n\n`;
      
      users.forEach((user, index) => {
        const status = user.status === 'active' ? '‚úÖ' : user.status === 'expired' ? '‚è∞' : '‚ùå';
        const name = user.first_name || user.username || 'Sem nome';
        const created = new Date(user.created_at).toLocaleDateString('pt-BR');
        
        response += `${index + 1}. ${status} **${name}**\n`;
        response += `   ID: \`${user.telegram_id}\`\n`;
        response += `   Status: ${user.status}\n`;
        response += `   Criado: ${created}\n\n`;
      });
      
      response += `**Comandos:**\n`;
      response += `‚Ä¢ \`/ban <user_id>\` - Banir usu√°rio\n`;
      response += `‚Ä¢ \`/unban <user_id>\` - Desbanir usu√°rio`;
      
      await this.bot.sendMessage(msg.chat.id, response, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('Erro ao listar usu√°rios:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao listar usu√°rios: ${error.message}`);
    }
  }
  
  async handleBanUser(msg, match) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    const userId = match[1];
    
    try {
      await database.run('UPDATE users SET is_active = 0, status = "banned" WHERE telegram_id = ?', [userId]);
      
      await database.saveActionLog('user_banned', userId, null, {
        banned_by: msg.from.id,
        reason: 'Banido via comando admin'
      });
      
      await this.bot.sendMessage(msg.chat.id, 
        `‚úÖ **Usu√°rio banido!**\n\n‚Ä¢ ID: \`${userId}\`\n‚Ä¢ A√ß√£o: Banimento\n‚Ä¢ Admin: ${msg.from.first_name}`, 
        { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('Erro ao banir usu√°rio:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao banir usu√°rio: ${error.message}`);
    }
  }
  
  async handleUnbanUser(msg, match) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    const userId = match[1];
    
    try {
      await database.run('UPDATE users SET is_active = 1, status = "inactive" WHERE telegram_id = ?', [userId]);
      
      await database.saveActionLog('user_unbanned', userId, null, {
        unbanned_by: msg.from.id,
        reason: 'Desbanido via comando admin'
      });
      
      await this.bot.sendMessage(msg.chat.id, 
        `‚úÖ **Usu√°rio desbanido!**\n\n‚Ä¢ ID: \`${userId}\`\n‚Ä¢ A√ß√£o: Desbloqueio\n‚Ä¢ Admin: ${msg.from.first_name}`, 
        { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('Erro ao desbanir usu√°rio:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao desbanir usu√°rio: ${error.message}`);
    }
  }

  // Capturar novos membros automaticamente
  async handleNewChatMembers(msg) {
    try {
      const groupId = msg.chat.id.toString();
      const groupName = msg.chat.title || 'Grupo sem nome';
      
      // Salvar informa√ß√µes do grupo
      await this.groupManager.saveGroup({
        telegram_id: groupId,
        name: groupName,
        type: msg.chat.type,
        member_count: await this.getChatMemberCount(groupId)
      });
      
      // Salvar cada novo membro
      for (const member of msg.new_chat_members) {
        if (!member.is_bot) {
          await this.groupManager.saveMember({
            user_id: member.id.toString(),
            group_id: groupId,
            username: member.username,
            first_name: member.first_name,
            last_name: member.last_name,
            is_active: true
          });
          
          console.log(`‚úÖ Novo membro capturado: ${member.first_name} (${member.id}) no grupo ${groupName}`);
        }
      }
    } catch (error) {
      console.error('‚ùå Erro ao capturar novos membros:', error.message);
    }
  }
  
  async handleLeftChatMember(msg) {
    try {
      const groupId = msg.chat.id.toString();
      const userId = msg.left_chat_member.id.toString();
      
      // Marcar membro como inativo
      await this.groupManager.updateMemberStatus(userId, groupId, false);
      
      console.log(`üëã Membro saiu: ${msg.left_chat_member.first_name} (${userId}) do grupo ${msg.chat.title}`);
    } catch (error) {
      console.error('‚ùå Erro ao processar sa√≠da de membro:', error.message);
    }
  }
  
  async handleMessage(msg) {
    try {
      // Registra intera√ß√£o do usu√°rio para sistema de DM
      if (msg.from && msg.from.id && !msg.from.is_bot) {
        await this.autoPostManager.registerUserInteraction(
          msg.from.id, 
          'message', 
          msg.chat.id
        );
      }
      
      // Capturar mensagens de grupos para identificar membros ativos
      if (msg.chat.type === 'group' || msg.chat.type === 'supergroup') {
        const groupId = msg.chat.id.toString();
        const userId = msg.from.id.toString();
        const groupName = msg.chat.title || 'Grupo sem nome';
        
        // Salvar/atualizar informa√ß√µes do grupo
        await this.groupManager.saveGroup({
          telegram_id: groupId,
          name: groupName,
          type: msg.chat.type,
          member_count: await this.getChatMemberCount(groupId)
        });
        
        // Salvar/atualizar membro se n√£o for bot
        if (!msg.from.is_bot) {
          await this.groupManager.saveMember({
            user_id: userId,
            group_id: groupId,
            username: msg.from.username,
            first_name: msg.from.first_name,
            last_name: msg.from.last_name,
            is_active: true
          });
        }
      }
    } catch (error) {
      console.error('‚ùå Erro ao processar mensagem:', error.message);
    }
  }
  
  async getChatMemberCount(chatId) {
    try {
      const count = await this.bot.getChatMemberCount(chatId);
      return count;
    } catch (error) {
      console.error('‚ùå Erro ao obter contagem de membros:', error.message);
      return 0;
    }
  }
  
  // === M√âTODOS DE AUTO-POST ===
  
  initializeAutoPost() {
    try {
      this.autoPostManager.startScheduler();
      console.log('‚úÖ Sistema de auto-post inicializado');
    } catch (error) {
      console.error('‚ùå Erro ao inicializar auto-post:', error.message);
    }
  }
  
  async handleAutoPost(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const status = await this.autoPostManager.getStatus();
      const stats = await this.autoPostManager.getStats();
      
      let response = `ü§ñ **Sistema de Auto-Post**\n\n`;
      response += `**üìä Status:**\n`;
      response += `‚Ä¢ Sistema: ${status.isActive ? '‚úÖ Ativo' : '‚ùå Inativo'}\n`;
      response += `‚Ä¢ Grupos ativos: ${status.activeGroups}\n`;
      response += `‚Ä¢ Pr√≥ximo post: ${status.nextPost || 'N/A'}\n\n`;
      
      response += `**üìà Estat√≠sticas:**\n`;
      response += `‚Ä¢ Posts hoje: ${stats.postsToday}\n`;
      response += `‚Ä¢ Posts esta semana: ${stats.postsThisWeek}\n`;
      response += `‚Ä¢ Total de posts: ${stats.totalPosts}\n`;
      response += `‚Ä¢ Taxa de sucesso: ${stats.successRate}%\n\n`;
      
      response += `**üéØ Comandos:**\n`;
      response += `‚Ä¢ \`/startauto\` - Iniciar sistema\n`;
      response += `‚Ä¢ \`/stopauto\` - Parar sistema\n`;
      response += `‚Ä¢ \`/togglepost <grupo_id>\` - Ativar/desativar grupo\n`;
      response += `‚Ä¢ \`/dmstats\` - Estat√≠sticas de DM\n`;
      response += `‚Ä¢ \`/testai\` - Testar gera√ß√£o de conte√∫do`;
      
      await this.bot.sendMessage(msg.chat.id, response, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('Erro no comando autopost:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao buscar status: ${error.message}`);
    }
  }
  
  async handleStartAuto(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const result = await this.autoPostManager.start();
      
      if (result.success) {
        await this.bot.sendMessage(msg.chat.id, 
          `‚úÖ **Sistema de auto-post iniciado!**\n\n‚Ä¢ Grupos ativos: ${result.activeGroups}\n‚Ä¢ Pr√≥ximo post: ${result.nextPost}`);
      } else {
        await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao iniciar: ${result.error}`);
      }
    } catch (error) {
      console.error('Erro ao iniciar auto-post:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao iniciar sistema: ${error.message}`);
    }
  }
  
  async handleStopAuto(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const result = await this.autoPostManager.stop();
      
      if (result.success) {
        await this.bot.sendMessage(msg.chat.id, 
          `üõë **Sistema de auto-post parado!**\n\n‚Ä¢ Posts realizados hoje: ${result.postsToday}\n‚Ä¢ Sistema estava ativo por: ${result.uptime}`);
      } else {
        await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao parar: ${result.error}`);
      }
    } catch (error) {
      console.error('Erro ao parar auto-post:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao parar sistema: ${error.message}`);
    }
  }
  
  async handleTogglePost(msg, match) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    const groupId = match[1];
    
    try {
      const result = await this.autoPostManager.toggleGroup(groupId);
      
      if (result.success) {
        const status = result.enabled ? 'ativado' : 'desativado';
        await this.bot.sendMessage(msg.chat.id, 
          `‚úÖ **Auto-post ${status} para o grupo!**\n\n‚Ä¢ Grupo: ${groupId}\n‚Ä¢ Status: ${result.enabled ? '‚úÖ Ativo' : '‚ùå Inativo'}`);
      } else {
        await this.bot.sendMessage(msg.chat.id, `‚ùå Erro: ${result.error}`);
      }
    } catch (error) {
      console.error('Erro ao alternar grupo:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao alternar grupo: ${error.message}`);
    }
  }
  
  async handleDMStats(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const stats = await this.autoPostManager.getDMStats();
      
      let response = `üì± **Estat√≠sticas de DM**\n\n`;
      response += `**üìä Hoje:**\n`;
      response += `‚Ä¢ DMs enviadas: ${stats.today.sent}\n`;
      response += `‚Ä¢ Sucessos: ${stats.today.success}\n`;
      response += `‚Ä¢ Falhas: ${stats.today.failed}\n`;
      response += `‚Ä¢ Taxa de sucesso: ${stats.today.successRate}%\n\n`;
      
      response += `**üìà Esta semana:**\n`;
      response += `‚Ä¢ Total de DMs: ${stats.week.total}\n`;
      response += `‚Ä¢ M√©dia di√°ria: ${stats.week.dailyAverage}\n`;
      response += `‚Ä¢ Convers√µes: ${stats.week.conversions}\n\n`;
      
      response += `**üéØ Performance:**\n`;
      response += `‚Ä¢ Melhor dia: ${stats.performance.bestDay}\n`;
      response += `‚Ä¢ Melhor hor√°rio: ${stats.performance.bestHour}h\n`;
      response += `‚Ä¢ Taxa geral: ${stats.performance.overallRate}%`;
      
      await this.bot.sendMessage(msg.chat.id, response, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('Erro ao buscar stats de DM:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao buscar estat√≠sticas: ${error.message}`);
    }
  }
  
  async handleTestAI(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const loadingMsg = await this.bot.sendMessage(msg.chat.id, 'ü§ñ Testando gera√ß√£o de conte√∫do com IA...');
      
      const testContent = await this.geminiAI.generateContent({
        type: 'promotional',
        topic: 'teste do sistema',
        style: 'engaging'
      });
      
      let response = `ü§ñ **Teste de Gera√ß√£o de Conte√∫do**\n\n`;
      response += `**üìù Conte√∫do gerado:**\n${testContent.text}\n\n`;
      response += `**üìä Detalhes:**\n`;
      response += `‚Ä¢ Tipo: ${testContent.type}\n`;
      response += `‚Ä¢ Palavras: ${testContent.wordCount}\n`;
      response += `‚Ä¢ Tempo: ${testContent.generationTime}ms\n`;
      response += `‚Ä¢ Qualidade: ${testContent.quality}/10`;
      
      await this.bot.editMessageText(response, {
        chat_id: msg.chat.id,
        message_id: loadingMsg.message_id,
        parse_mode: 'Markdown'
      });
      
    } catch (error) {
      console.error('Erro no teste de IA:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro no teste: ${error.message}`);
    }
  }

  // Para o bot
  stop() {
    if (this.autoPostManager) {
      this.autoPostManager.stop();
    }
    if (this.bot) {
      this.bot.stopPolling();
      console.log('üõë Bot Telegram parado');
    }
  }
}

module.exports = TelegramSubscriptionBot;