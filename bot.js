const TelegramBot = require('node-telegram-bot-api');
const moment = require('moment');
const fetch = require('node-fetch');
const database = require('./db');
const infinitePayService = require('./services/infinitepay');
const GroupManager = require('./services/groupManager');
const BackupManager = require('./services/backupManager');
const AutoPostManager = require('./services/autoPostManager');
const GeminiAIService = require('./services/geminiAI');
const IdentifierResolver = require('./utils/identifierResolver');
require('dotenv').config();

// Configura√ß√£o do momento para portugu√™s
moment.locale('pt-br');

class TelegramSubscriptionBot {
  constructor() {
    this.token = process.env.TELEGRAM_BOT_TOKEN;
    this.adminIds = process.env.ADMIN_IDS ? process.env.ADMIN_IDS.split(',').map(id => id.trim()) : [];
    
    if (!this.token) {
      throw new Error('‚ùå Token do bot Telegram n√£o configurado');
    }
    
    // Usar polling em desenvolvimento local para evitar conflito com Railway
    const isLocal = process.env.NODE_ENV === 'development';
    
    if (isLocal) {
      // Modo polling para desenvolvimento local
      this.bot = new TelegramBot(this.token, { polling: true });
      console.log('üîÑ Bot configurado em modo polling (local)');
    } else {
      // Modo webhook para produ√ß√£o (Railway)
      this.bot = new TelegramBot(this.token, { webHook: true });
      console.log('üîÑ Bot configurado em modo webhook (produ√ß√£o)');
      
      // Configura webhook do Telegram
      this.setupWebhook();
    }
    
    // Inicializa servi√ßos ap√≥s criar o bot
    this.groupManager = new GroupManager(this.bot, database);
    this.backupManager = new BackupManager();
    this.autoPostManager = new AutoPostManager(this.bot);
    this.geminiAI = new GeminiAIService();
    this.identifierResolver = new IdentifierResolver(this.bot);
    
    this.setupHandlers();
    
    console.log('ü§ñ Bot Telegram inicializado');
  }

  // Configura webhook do Telegram para produ√ß√£o
  async setupWebhook() {
    try {
      const webhookUrl = process.env.TELEGRAM_WEBHOOK_URL;
      
      if (!webhookUrl) {
        console.error('‚ùå TELEGRAM_WEBHOOK_URL n√£o configurada');
        return;
      }
      
      // Remove webhook existente
      await this.bot.deleteWebHook();
      console.log('üóëÔ∏è Webhook anterior removido');
      
      // Configura novo webhook
      await this.bot.setWebHook(webhookUrl);
      console.log(`‚úÖ Webhook configurado: ${webhookUrl}`);
      
      // Verifica se webhook foi configurado corretamente
      const webhookInfo = await this.bot.getWebHookInfo();
      console.log('üìã Info do webhook:', {
        url: webhookInfo.url,
        has_custom_certificate: webhookInfo.has_custom_certificate,
        pending_update_count: webhookInfo.pending_update_count,
        last_error_date: webhookInfo.last_error_date,
        last_error_message: webhookInfo.last_error_message
      });
      
    } catch (error) {
      console.error('‚ùå Erro ao configurar webhook:', error.message);
    }
  }

  // Configura todos os handlers do bot
  setupHandlers() {
    // Comando /start
    this.bot.onText(/\/start/, (msg) => this.handleStart(msg));
    
    // Comandos admin
    this.bot.onText(/\/assinantes/, (msg) => this.handleAssinantes(msg));
    this.bot.onText(/\/reenviar (.+)/, (msg, match) => this.handleReenviar(msg, match));
    this.bot.onText(/\/stats/, (msg) => this.handleStats(msg));
    
    // Novos comandos administrativos com suporte a @ e links
    this.bot.onText(/\/grupos/, (msg) => this.handleGroups(msg));
    this.bot.onText(/\/scrape (.+)/, (msg, match) => this.handleStartScraping(msg, match));
    this.bot.onText(/\/addgrupo (.+) (.+)/, (msg, match) => this.handleAddGroupWithIdentifier(msg, match));
    this.bot.onText(/\/membros (.+)/, (msg, match) => this.handleGroupMembers(msg, match));
    this.bot.onText(/\/replicar (.+) (.+)/, (msg, match) => this.handleReplicateMembers(msg, match));
    this.bot.onText(/\/autoadd (.+) (.+)/, (msg, match) => this.handleAutoAdd(msg, match));
    this.bot.onText(/\/usuario (.+)/, (msg, match) => this.handleUserInfo(msg, match));
    this.bot.onText(/\/grupo (.+)/, (msg, match) => this.handleGroupInfo(msg, match));
    this.bot.onText(/\/bulkadd (.+)/, (msg, match) => this.handleBulkAdd(msg, match));
    this.bot.onText(/\/jobs/, (msg) => this.handleScrapingJobs(msg));
    this.bot.onText(/\/logs/, (msg) => this.handleLogs(msg));
    this.bot.onText(/\/admin/, (msg) => this.handleAdminPanel(msg));
    this.bot.onText(/\/painel/, (msg) => this.handleAdminPanel(msg));
    this.bot.onText(/\/backup/, (msg) => this.handleBackup(msg));
    this.bot.onText(/\/replicar (.+) (.+)/, (msg, match) => this.handleReplicate(msg, match));
    this.bot.onText(/\/restaurar/, (msg) => this.handleRestore(msg));
    this.bot.onText(/\/limpar/, (msg) => this.handleCleanup(msg));
    this.bot.onText(/\/config/, (msg) => this.handleConfig(msg));
    this.bot.onText(/\/set (.+) (.+)/, (msg, match) => this.handleSetConfig(msg, match));
    this.bot.onText(/\/estatisticas/, (msg) => this.handleAdvancedStats(msg));
    this.bot.onText(/\/sistema/, (msg) => this.handleSystemInfo(msg));
    this.bot.onText(/\/usuarios/, (msg) => this.handleUsers(msg));
    this.bot.onText(/\/ban (.+)/, (msg, match) => this.handleBanUser(msg, match));
    this.bot.onText(/\/unban (.+)/, (msg, match) => this.handleUnbanUser(msg, match));
    this.bot.onText(/\/autopost/, (msg) => this.handleAutoPost(msg));
    this.bot.onText(/\/startauto/, (msg) => this.handleStartAuto(msg));
    this.bot.onText(/\/stopauto/, (msg) => this.handleStopAuto(msg));
    this.bot.onText(/\/togglepost (.+)/, (msg, match) => this.handleTogglePost(msg, match));
    this.bot.onText(/\/dmstats/, (msg) => this.handleDMStats(msg));
    this.bot.onText(/\/testai/, (msg) => this.handleTestAI(msg));
    
    // Callback queries (bot√µes)
    this.bot.on('callback_query', (callbackQuery) => this.handleCallbackQuery(callbackQuery));
    
    // Eventos de grupo para capturar membros
    this.bot.on('new_chat_members', (msg) => this.handleNewChatMembers(msg));
    this.bot.on('left_chat_member', (msg) => this.handleLeftChatMember(msg));
    this.bot.on('message', (msg) => this.handleMessage(msg));
    
    // Inicia sistema de auto-post
    this.initializeAutoPost();
    
    // Tratamento de erros
    this.bot.on('polling_error', (error) => {
      console.error('‚ùå Erro no polling:', error.message);
    });
    
    console.log('‚úÖ Handlers do bot configurados');
  }

  // Verifica se usu√°rio √© admin
  isAdmin(userId) {
    return this.adminIds.includes(userId.toString());
  }

  // Handler do comando /start
  async handleStart(msg) {
    try {
      const chatId = msg.chat.id;
      const user = msg.from;
      
      // Verifica se o comando foi executado em um grupo
      if (msg.chat.type === 'group' || msg.chat.type === 'supergroup') {
        const botUsername = this.bot.options.username || process.env.BOT_USERNAME;
        const privateLink = `https://t.me/${botUsername}?start=grupo`;
        
        await this.bot.sendMessage(chatId, 
          `ü§ñ Ol√° ${user.first_name}!\n\n` +
          `Para usar o bot, voc√™ precisa conversar comigo no chat privado.\n\n` +
          `üëÜ Clique no link abaixo para iniciar:\n${privateLink}`,
          {
            parse_mode: 'Markdown',
            reply_to_message_id: msg.message_id
          }
        );
        return;
      }
      
      console.log(`üë§ Usu√°rio ${user.first_name} (${user.id}) iniciou conversa`);
      
      // Busca ou cria usu√°rio no banco
      const dbUser = await database.findOrCreateUser(user);
      
      // Verifica√ß√£o de seguran√ßa para garantir que o usu√°rio foi criado corretamente
      if (!dbUser) {
        console.error('‚ùå Erro: falha ao criar/buscar usu√°rio no banco de dados');
        await this.bot.sendMessage(chatId, '‚ùå Erro interno. Tente novamente em alguns segundos.');
        return;
      }
      
      console.log(`‚úÖ Usu√°rio carregado:`, {
        id: dbUser.id,
        telegram_id: dbUser.telegram_id,
        status: dbUser.status || 'inactive'
      });
      
      // Monta mensagem de apresenta√ß√£o
      const productName = process.env.PRODUCT_NAME || 'Produto Premium';
      const productDescription = process.env.PRODUCT_DESCRIPTION || 'Acesso exclusivo ao conte√∫do VIP';
      const subscriptionPrice = parseInt(process.env.SUBSCRIPTION_PRICE) || 4990;
      const priceFormatted = infinitePayService.formatCurrency(subscriptionPrice);
      
      const welcomeMessage = `üéØ *${productName.replace(/[_*\[\]()~`>#+=|{}.!-]/g, '\\$&')}*

${productDescription.replace(/[_*\[\]()~`>#+=|{}.!-]/g, '\\$&')}

üí∞ *${priceFormatted.replace(/[_*\[\]()~`>#+=|{}.!-]/g, '\\$&')} / m√™s*

${this.getSubscriptionStatusMessage(dbUser)}

üì± Clique no bot√£o abaixo para assinar:`;
      
      const keyboard = this.getMainKeyboard(dbUser);
      
      // Envia imagem se configurada e v√°lida
      const productImageUrl = process.env.PRODUCT_IMAGE_URL;
      
      if (productImageUrl && productImageUrl.trim() && productImageUrl.startsWith('http') && !productImageUrl.includes('exemplo.com')) {
        try {
          // Valida se a URL √© uma imagem v√°lida
          const response = await fetch(productImageUrl, { method: 'HEAD' });
          const contentType = response.headers.get('content-type');
          
          if (response.ok && contentType && contentType.startsWith('image/')) {
            await this.bot.sendPhoto(chatId, productImageUrl, {
              caption: welcomeMessage,
              parse_mode: 'Markdown',
              reply_markup: keyboard
            });
          } else {
            throw new Error('URL n√£o retorna uma imagem v√°lida');
          }
        } catch (imageError) {
          console.warn('‚ö†Ô∏è Erro ao enviar imagem, enviando apenas texto:', imageError.message);
          await this.bot.sendMessage(chatId, welcomeMessage, {
            parse_mode: 'Markdown',
            reply_markup: keyboard
          });
        }
      } else {
        await this.bot.sendMessage(chatId, welcomeMessage, {
          parse_mode: 'Markdown',
          reply_markup: keyboard
        });
      }
    } catch (error) {
      console.error('‚ùå Erro no comando /start:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro interno. Tente novamente.');
    }
  }

  // Retorna mensagem de status da assinatura
  getSubscriptionStatusMessage(user) {
    // Verifica√ß√£o de seguran√ßa para evitar erro de propriedade undefined
    if (!user || typeof user !== 'object') {
      console.error('‚ùå Erro: usu√°rio undefined ou inv√°lido em getSubscriptionStatusMessage');
      return 'üîì *Sem Assinatura Ativa*\nAssine para ter acesso completo';
    }
    
    // Define status padr√£o se n√£o existir
    const status = user.status || 'inactive';
    
    if (status === 'active' && user.subscription_end) {
      try {
        const endDate = moment(user.subscription_end).format('DD/MM/YYYY');
        return `‚úÖ *Assinatura Ativa*\nV√°lida at√©: ${endDate}`;
      } catch (dateError) {
        console.warn('‚ö†Ô∏è Erro ao formatar data de expira√ß√£o:', dateError.message);
        return '‚úÖ *Assinatura Ativa*\nData de expira√ß√£o indispon√≠vel';
      }
    } else if (status === 'expired') {
      return '‚è∞ *Assinatura Expirada*\nRenove para continuar acessando';
    } else {
      return 'üîì *Sem Assinatura Ativa*\nAssine para ter acesso completo';
    }
  }

  // Retorna teclado principal baseado no status do usu√°rio
  getMainKeyboard(user) {
    const buttons = [];
    
    // Verifica√ß√£o de seguran√ßa para usu√°rio v√°lido
    if (!user || typeof user !== 'object') {
      console.warn('‚ö†Ô∏è Usu√°rio inv√°lido em getMainKeyboard, usando bot√µes padr√£o');
      buttons.push([{ text: 'üëâ Assinar Agora', callback_data: 'subscribe_now' }]);
      buttons.push([{ text: 'üìû Suporte', callback_data: 'support' }]);
      return { inline_keyboard: buttons };
    }
    
    const status = user.status || 'inactive';
    
    if (status === 'active') {
      buttons.push([{ text: '‚úÖ Assinatura Ativa', callback_data: 'subscription_status' }]);
      buttons.push([{ text: 'üîÑ Renovar Assinatura', callback_data: 'renew_subscription' }]);
    } else {
      buttons.push([{ text: 'üëâ Assinar Agora', callback_data: 'subscribe_now' }]);
    }
    
    buttons.push([{ text: 'üìû Suporte', callback_data: 'support' }]);
    
    return { inline_keyboard: buttons };
  }

  // Handler de callback queries (bot√µes)
  async handleCallbackQuery(callbackQuery) {
    try {
      const chatId = callbackQuery.message.chat.id;
      const userId = callbackQuery.from.id;
      const data = callbackQuery.data;
      
      // Registra intera√ß√£o para DM
      if (userId && !callbackQuery.from.is_bot) {
        await this.autoPostManager.registerUserInteraction(
          userId, 
          'callback_query', 
          chatId
        );
      }
      
      // Responde ao callback para remover loading
      await this.bot.answerCallbackQuery(callbackQuery.id);
      
      console.log(`üîò Callback recebido: ${data} de ${userId}`);
      
      switch (data) {
        case 'subscribe_now':
        case 'renew_subscription':
          await this.handleSubscription(chatId, userId);
          break;
          
        case 'subscription_status':
          await this.handleSubscriptionStatus(chatId, userId);
          break;
          
        case 'support':
          await this.handleSupport(chatId);
          break;
          
        case 'unsubscribe_dm':
          await this.handleUnsubscribeDM(callbackQuery);
          break;
          
        case 'subscription':
          await this.handleSubscription(chatId, userId);
          break;
          
        case 'subscribe_now':
          await this.handleSubscription(chatId, userId);
          break;
          
        // Novos bot√µes para conte√∫do adulto +18
        case 'acesso_exclusivo':
          await this.handleAcessoExclusivo(chatId, userId);
          break;
          
        case 'assinar_premium':
          await this.handleAssinarPremium(chatId, userId);
          break;
          
        case 'acesso_18':
          await this.handleAcesso18(chatId, userId);
          break;
          
        case 'comprar_assinatura':
          await this.handleComprarAssinatura(chatId, userId);
          break;
          
        case 'cancelar_dms':
          await this.handleCancelarDMs(callbackQuery);
          break;
          
        // Novos planos de assinatura
        case 'plan_week':
          await this.handlePlanWeek(chatId, userId);
          break;
          
        case 'plan_month':
          await this.handlePlanMonth(chatId, userId);
          break;
          
        case 'plan_year':
          await this.handlePlanYear(chatId, userId);
          break;
          
        case 'back_main':
          await this.handleStart({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        // Callbacks do painel administrativo
        case 'admin_grupos':
          await this.handleAdminGrupos(callbackQuery);
          break;
          
        case 'admin_stats':
          await this.handleAdminStats(callbackQuery);
          break;
          
        case 'admin_usuarios':
          await this.handleAdminUsuarios(callbackQuery);
          break;
          
        case 'admin_backup':
          await this.handleAdminBackup(callbackQuery);
          break;
          
        case 'admin_autopost':
          await this.handleAdminAutoPost(callbackQuery);
          break;
          
        case 'admin_sistema':
          await this.handleAdminSistema(callbackQuery);
          break;
          
        case 'admin_config':
          await this.handleAdminConfig(callbackQuery);
          break;
          
        case 'admin_jobs':
          await this.handleAdminJobs(callbackQuery);
          break;
          
        case 'admin_refresh':
          await this.handleAdminPanel({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        // Callbacks espec√≠ficos - Grupos
        case 'grupos_listar':
          await this.handleGroups({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        case 'grupos_membros':
          await this.bot.sendMessage(chatId, 'üë• Para ver membros de um grupo, use: `/members <grupo_id>`\n\nPrimeiro liste os grupos para ver os IDs dispon√≠veis.', { parse_mode: 'Markdown' });
          break;
          
        case 'grupos_scraping':
          await this.bot.sendMessage(chatId, 'üîç Para iniciar scraping, use: `/scrape <grupo_id>`\n\nPrimeiro liste os grupos para ver os IDs dispon√≠veis.', { parse_mode: 'Markdown' });
          break;
          
        case 'grupos_add_user':
          await this.bot.sendMessage(chatId, '‚ûï Para adicionar usu√°rio, use: `/autoadd <grupo_id> <user_id>`\n\nExemplo: `/autoadd 123456789 987654321`', { parse_mode: 'Markdown' });
          break;
          
        case 'grupos_bulk_add':
          await this.bot.sendMessage(chatId, 'üì¶ Para adi√ß√£o em massa, use: `/bulkadd <grupo_origem> <grupo_destino> <quantidade>`\n\nExemplo: `/bulkadd 123456789 987654321 50`', { parse_mode: 'Markdown' });
          break;
          
        case 'grupos_replicar':
          await this.bot.sendMessage(chatId, 'üîÑ Para replicar membros, use: `/replicate <grupo_origem> <grupo_destino>`\n\nExemplo: `/replicate @grupo1 @grupo2`', { parse_mode: 'Markdown' });
          break;
          
        case 'grupos_jobs':
          await this.handleScrapingJobs({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        case 'grupos_add_grupo':
          await this.handleAddGroup({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        // Callbacks espec√≠ficos - Stats
        case 'stats_basicas':
          await this.handleStats({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        case 'stats_avancadas':
          await this.handleAdvancedStats({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        case 'stats_assinantes':
          await this.handleAssinantes({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        case 'stats_dm':
          await this.handleDMStats({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        case 'stats_logs':
          await this.handleLogs({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        case 'stats_sistema':
        case 'sistema_info':
          await this.handleSystemInfo({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        case 'sistema_stats':
          await this.handleAdvancedStats({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        case 'sistema_logs':
          await this.handleLogs({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        case 'sistema_status':
          await this.handleAutoPost({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        // Callbacks espec√≠ficos - Usu√°rios
        case 'users_listar':
          await this.handleUsers({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        case 'users_ban':
          await this.bot.sendMessage(chatId, 'üö´ Para banir um usu√°rio, use: `/ban <user_id>`', { parse_mode: 'Markdown' });
          break;
          
        case 'users_unban':
          await this.bot.sendMessage(chatId, '‚úÖ Para desbanir um usu√°rio, use: `/unban <user_id>`', { parse_mode: 'Markdown' });
          break;
          
        case 'users_buscar':
          await this.bot.sendMessage(chatId, 'üîç Para buscar um usu√°rio, use: `/userinfo <user_id>`\n\nExemplo: `/userinfo 123456789`', { parse_mode: 'Markdown' });
          break;
          
        // Callbacks espec√≠ficos - Backup
        case 'backup_criar':
          await this.handleBackup({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        case 'backup_listar':
          await this.bot.sendMessage(chatId, 'üìã **Backups Dispon√≠veis**\n\nUse `/backup` para ver a lista completa de backups dispon√≠veis.', { parse_mode: 'Markdown' });
          break;
          
        case 'backup_restaurar':
          await this.handleRestore({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        case 'backup_limpar':
          await this.handleCleanup({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        // Callbacks espec√≠ficos - AutoPost
        case 'autopost_status':
          await this.handleAutoPost({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        case 'autopost_start':
          await this.handleStartAuto({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        case 'autopost_stop':
          await this.handleStopAuto({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        case 'autopost_toggle':
          await this.bot.sendMessage(chatId, 'üîÑ Para alternar auto-post em um grupo, use: `/toggle <grupo_id>`\n\nExemplo: `/toggle 123456789`', { parse_mode: 'Markdown' });
          break;
          
        case 'autopost_test_ai':
          await this.handleTestAI({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        case 'autopost_dm_stats':
          await this.handleDMStats({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        // Callbacks espec√≠ficos - Config
        case 'config_ver':
          await this.handleConfig({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        // Callbacks espec√≠ficos - Jobs
        case 'jobs_ativos':
          await this.handleScrapingJobs({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        case 'jobs_scraping':
          await this.handleScrapingJobs({ chat: { id: chatId }, from: { id: userId } });
          break;
          
        default:
          console.log(`‚ùì Callback n√£o reconhecido: ${data}`);
          await this.bot.sendMessage(chatId, `‚ö†Ô∏è Fun√ß√£o "${data}" ainda n√£o implementada.\n\nEm breve estar√° dispon√≠vel!`, { parse_mode: 'Markdown' });
      }
    } catch (error) {
      console.error('‚ùå Erro no callback query:', error.message);
      
      // Ignora erros espec√≠ficos do Telegram que n√£o s√£o cr√≠ticos
      if (error.message && (
        error.message.includes('message is not modified') ||
        error.message.includes('Bad Request: message is not modified') ||
        error.message.includes('can\'t parse entities') ||
        error.message.includes('Bad Request: can\'t parse entities')
      )) {
        console.log('‚ö†Ô∏è Erro conhecido do Telegram - ignorando:', error.message);
        return;
      }
      
      // Verifica se callbackQuery e suas propriedades existem antes de usar
      if (!callbackQuery || !callbackQuery.message || !callbackQuery.message.chat) {
        console.error('‚ùå CallbackQuery inv√°lido ou incompleto');
        return;
      }
      
      // Para outros erros, notifica o usu√°rio
      try {
        await this.bot.sendMessage(callbackQuery.message.chat.id, '‚ùå Erro interno. Tente novamente.');
      } catch (sendError) {
        console.error('‚ùå Erro ao enviar mensagem de erro:', sendError.message);
      }
    }
  }

  // Processa assinatura/renova√ß√£o
  async handleSubscription(chatId, userId) {
    try {
      const user = await database.getUserByTelegramId(userId);
      
      if (!user) {
        await this.bot.sendMessage(chatId, '‚ùå Usu√°rio n√£o encontrado. Use /start primeiro.');
        return;
      }
      
      // Apresenta op√ß√µes de planos
      await this.bot.sendMessage(chatId, 
        'üíé **ESCOLHA SEU PLANO PREMIUM**\n\n' +
        'üî• Acesso total ao conte√∫do exclusivo +18\n' +
        'üì± Conte√∫do premium ilimitado\n' +
        'üéØ Suporte priorit√°rio\n\n' +
        'üí∞ **PLANOS DISPON√çVEIS:**',
        {
          parse_mode: 'Markdown',
          reply_markup: {
            inline_keyboard: [
              [
                { text: '‚ö° 1 Semana - R$ 20,00', callback_data: 'plan_week' }
              ],
              [
                { text: 'üî• 1 M√™s - R$ 35,00', callback_data: 'plan_month' }
              ],
              [
                { text: 'üíé 1 Ano - R$ 145,00 (MELHOR OFERTA)', callback_data: 'plan_year' }
              ],
              [
                { text: 'üîô Voltar', callback_data: 'back_main' }
              ]
            ]
          }
        }
      );
      
    } catch (error) {
      console.error('‚ùå Erro ao processar assinatura:', error.message);
      await this.bot.sendMessage(chatId, '‚ùå Erro ao gerar cobran√ßa. Tente novamente ou entre em contato com o suporte.');
    }
  }

  // Envia cobran√ßa Pix para o usu√°rio
  async sendPixCharge(chatId, charge, dueDate) {
    const priceFormatted = infinitePayService.formatCurrency(charge.amount);
    const dueDateFormatted = moment(dueDate).format('DD/MM/YYYY');
    
    const message = `
üí≥ *Cobran√ßa Gerada*

üí∞ Valor: *${priceFormatted}*
üìÖ Vencimento: *${dueDateFormatted}*

üì± *Pix Copia e Cola:*
\`${charge.pix_code}\`

‚ö° Ap√≥s o pagamento, sua assinatura ser√° ativada automaticamente!

‚è∞ Voc√™ tem at√© ${dueDateFormatted} para efetuar o pagamento.`;
    
    const keyboard = {
      inline_keyboard: [
        [{ text: 'üîÑ Verificar Pagamento', callback_data: `check_payment_${charge.id}` }],
        [{ text: 'üìû Suporte', callback_data: 'support' }]
      ]
    };
    
    // Envia QR Code se dispon√≠vel
    if (charge.qr_code_url) {
      try {
        await this.bot.sendPhoto(chatId, charge.qr_code_url, {
          caption: message,
          parse_mode: 'Markdown',
          reply_markup: keyboard
        });
      } catch (error) {
        // Se falhar ao enviar imagem, envia s√≥ texto
        await this.bot.sendMessage(chatId, message, {
          parse_mode: 'Markdown',
          reply_markup: keyboard
        });
      }
    } else {
      await this.bot.sendMessage(chatId, message, {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      });
    }
  }

  // Mostra status da assinatura
  async handleSubscriptionStatus(chatId, userId) {
    try {
      const user = await database.getUserByTelegramId(userId);
      
      if (!user) {
        await this.bot.sendMessage(chatId, '‚ùå Usu√°rio n√£o encontrado.');
        return;
      }
      
      let message = `üìä *Status da Assinatura*\n\n`;
      
      if (user.status === 'active') {
        const endDate = moment(user.subscription_end).format('DD/MM/YYYY HH:mm');
        const daysLeft = moment(user.subscription_end).diff(moment(), 'days');
        
        message += `‚úÖ *Status:* Ativa\n`;
        message += `üìÖ *V√°lida at√©:* ${endDate}\n`;
        message += `‚è∞ *Dias restantes:* ${daysLeft} dias\n`;
        
        if (user.last_payment_date) {
          const lastPayment = moment(user.last_payment_date).format('DD/MM/YYYY');
          message += `üí≥ *√öltimo pagamento:* ${lastPayment}`;
        }
      } else {
        message += `‚ùå *Status:* ${user.status === 'expired' ? 'Expirada' : 'Inativa'}\n`;
        message += `üìù *A√ß√£o:* Assine para ter acesso completo`;
      }
      
      await this.bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('‚ùå Erro ao consultar status:', error.message);
      await this.bot.sendMessage(chatId, '‚ùå Erro ao consultar status.');
    }
  }

  // Handler de suporte
  async handleSupport(chatId) {
    const supportMessage = `
üìû *Suporte ao Cliente*

Precisa de ajuda? Entre em contato:

‚Ä¢ üí¨ Chat: @seususuario
‚Ä¢ üìß Email: suporte@seudominio.com
‚Ä¢ üì± WhatsApp: (11) 99999-9999

‚è∞ Hor√°rio de atendimento:
Segunda a Sexta: 9h √†s 18h`;
    
    await this.bot.sendMessage(chatId, supportMessage, { parse_mode: 'Markdown' });
  }

  // Handler para cancelar DMs autom√°ticas
  async handleUnsubscribeDM(callbackQuery) {
    try {
      const userId = callbackQuery.from.id;
      const chatId = callbackQuery.message.chat.id;
      
      // Atualiza o consentimento do usu√°rio
      await database.query(
        'UPDATE users SET dm_consent = false WHERE telegram_id = ?',
        [userId.toString()]
      );
      
      const message = `‚úÖ **DMs Canceladas**\n\nVoc√™ n√£o receber√° mais mensagens autom√°ticas.\n\nPara reativar, use o comando /start e interaja novamente.`;
      
      await this.bot.editMessageText(message, {
        chat_id: chatId,
        message_id: callbackQuery.message.message_id,
        parse_mode: 'Markdown'
      });
      
      console.log(`üö´ Usu√°rio ${userId} cancelou DMs autom√°ticas`);
      
    } catch (error) {
      console.error('‚ùå Erro ao cancelar DMs:', error.message);
      await this.bot.sendMessage(callbackQuery.message.chat.id, '‚ùå Erro ao processar cancelamento.');
    }
  }

  // Novos handlers para bot√µes de conte√∫do adulto +18
  async handleAcessoExclusivo(chatId, userId) {
    try {
      // Verifica se o usu√°rio tem assinatura ativa
      const user = await database.get(
        'SELECT * FROM users WHERE telegram_id = ?',
        [userId]
      );
      
      if (!user) {
        await this.bot.sendMessage(chatId, 
          'üîû Para acessar conte√∫do exclusivo +18, voc√™ precisa se registrar primeiro!\n\n' +
          'üëÜ Use /start para come√ßar.'
        );
        return;
      }
      
      const now = new Date();
      const subscriptionEnd = user.subscription_end ? new Date(user.subscription_end) : null;
      
      if (!subscriptionEnd || subscriptionEnd <= now) {
        await this.bot.sendMessage(chatId, 
          'üîûüíé **ACESSO EXCLUSIVO +18**\n\n' +
          'üî• Conte√∫do adulto premium dispon√≠vel apenas para assinantes VIP!\n\n' +
          'üíã O que voc√™ encontrar√°:\n' +
          '‚Ä¢ Fotos e v√≠deos exclusivos\n' +
          '‚Ä¢ Conte√∫do √≠ntimo e provocante\n' +
          '‚Ä¢ Atualiza√ß√µes di√°rias\n' +
          '‚Ä¢ Acesso priorit√°rio\n\n' +
          'üíé **Assine agora e tenha acesso imediato!**',
          {
            parse_mode: 'Markdown',
            reply_markup: {
              inline_keyboard: [[
                { text: 'üíé Assinar Premium', callback_data: 'subscribe_now' },
                { text: 'üìû Suporte', callback_data: 'support' }
              ]]
            }
          }
        );
      } else {
        await this.bot.sendMessage(chatId, 
          'üî•üíé **BEM-VINDO AO ACESSO EXCLUSIVO +18!**\n\n' +
          'üíã Voc√™ tem acesso total ao conte√∫do premium!\n\n' +
          `‚è∞ Sua assinatura expira em: ${moment(subscriptionEnd).format('DD/MM/YYYY HH:mm')}\n\n` +
          'üîû Aproveite todo o conte√∫do exclusivo dispon√≠vel!',
          {
            parse_mode: 'Markdown',
            reply_markup: {
              inline_keyboard: [[
                { text: 'üì± Ver Conte√∫do', url: `https://t.me/${process.env.BOT_USERNAME}` },
                { text: 'üîÑ Renovar', callback_data: 'renew_subscription' }
              ]]
            }
          }
        );
      }
      
      console.log(`üîû Usu√°rio ${userId} acessou conte√∫do exclusivo`);
      
    } catch (error) {
      console.error('‚ùå Erro no acesso exclusivo:', error.message);
      await this.bot.sendMessage(chatId, '‚ùå Erro interno. Tente novamente.');
    }
  }

  async handleAssinarPremium(chatId, userId) {
    try {
      await this.handleSubscription(chatId, userId);
      console.log(`üíé Usu√°rio ${userId} clicou em assinar premium`);
    } catch (error) {
      console.error('‚ùå Erro na assinatura premium:', error.message);
      await this.bot.sendMessage(chatId, '‚ùå Erro interno. Tente novamente.');
    }
  }

  async handleAcesso18(chatId, userId) {
    try {
      await this.handleAcessoExclusivo(chatId, userId);
      console.log(`üîû Usu√°rio ${userId} clicou em acesso +18`);
    } catch (error) {
      console.error('‚ùå Erro no acesso +18:', error.message);
      await this.bot.sendMessage(chatId, '‚ùå Erro interno. Tente novamente.');
    }
  }

  async handleComprarAssinatura(chatId, userId) {
    try {
      await this.handleSubscription(chatId, userId);
      console.log(`üí∞ Usu√°rio ${userId} clicou em comprar assinatura`);
    } catch (error) {
      console.error('‚ùå Erro na compra de assinatura:', error.message);
      await this.bot.sendMessage(chatId, '‚ùå Erro interno. Tente novamente.');
    }
  }

  async handleCancelarDMs(callbackQuery) {
    try {
      const userId = callbackQuery.from.id;
      const chatId = callbackQuery.message.chat.id;
      
      // Atualiza o consentimento do usu√°rio
      await database.query(
        'UPDATE users SET dm_consent = false WHERE telegram_id = ?',
        [userId.toString()]
      );
      
      const message = `‚úÖ **DMs Cancelados com Sucesso!**\n\nüìµ Voc√™ n√£o receber√° mais mensagens autom√°ticas.\n\nüí° **Para reativar:**\n‚Ä¢ Use o comando /start\n‚Ä¢ Ou clique em qualquer bot√£o de acesso\n\nüîû Mas lembre-se: voc√™ pode estar perdendo conte√∫do exclusivo!`;
      
      await this.bot.editMessageText(message, {
        chat_id: chatId,
        message_id: callbackQuery.message.message_id,
        parse_mode: 'Markdown',
        reply_markup: {
          inline_keyboard: [[
            { text: 'üîÑ Reativar DMs', callback_data: 'subscribe_now' },
            { text: 'üìû Suporte', callback_data: 'support' }
          ]]
        }
      });
      
      console.log(`üìµ Usu√°rio ${userId} cancelou DMs via bot√£o`);
      
    } catch (error) {
      console.error('‚ùå Erro ao cancelar DMs:', error.message);
      await this.bot.sendMessage(callbackQuery.message.chat.id, 
        '‚ùå Erro ao processar cancelamento. Tente novamente.'
      );
    }
  }

  // M√©todos para planos espec√≠ficos
  async handlePlanWeek(chatId, userId) {
    try {
      const user = await database.getUserByTelegramId(userId);
      
      if (!user) {
        await this.bot.sendMessage(chatId, '‚ùå Usu√°rio n√£o encontrado. Use /start primeiro.');
        return;
      }

      await this.bot.sendMessage(chatId, 
        '‚ö° **PLANO SEMANAL - R$ 20,00**\n\n' +
        'üî• 7 dias de acesso total\n' +
        'üì± Conte√∫do premium ilimitado\n' +
        'üéØ Suporte priorit√°rio\n\n' +
        'üí≥ **Clique no link abaixo para pagar:**',
        {
          parse_mode: 'Markdown',
          reply_markup: {
            inline_keyboard: [
              [
                 { text: 'üí≥ Pagar R$ 20,00 - 1 Semana', url: process.env.PLAN_WEEK_LINK }
               ],
              [
                { text: 'üîô Voltar aos Planos', callback_data: 'subscribe_now' }
              ]
            ]
          }
        }
      );
      
      console.log(`‚ö° Usu√°rio ${userId} selecionou plano semanal`);
      
    } catch (error) {
      console.error('‚ùå Erro no plano semanal:', error.message);
      await this.bot.sendMessage(chatId, '‚ùå Erro interno. Tente novamente.');
    }
  }

  async handlePlanMonth(chatId, userId) {
    try {
      const user = await database.getUserByTelegramId(userId);
      
      if (!user) {
        await this.bot.sendMessage(chatId, '‚ùå Usu√°rio n√£o encontrado. Use /start primeiro.');
        return;
      }

      await this.bot.sendMessage(chatId, 
        'üî• **PLANO MENSAL - R$ 35,00**\n\n' +
        'üíé 30 dias de acesso total\n' +
        'üì± Conte√∫do premium ilimitado\n' +
        'üéØ Suporte priorit√°rio\n' +
        'üí∞ Economia de R$ 25,00 vs semanal\n\n' +
        'üí≥ **Clique no link abaixo para pagar:**',
        {
          parse_mode: 'Markdown',
          reply_markup: {
            inline_keyboard: [
              [
                 { text: 'üí≥ Pagar R$ 35,00 - 1 M√™s', url: process.env.PLAN_MONTH_LINK }
               ],
              [
                { text: 'üîô Voltar aos Planos', callback_data: 'subscribe_now' }
              ]
            ]
          }
        }
      );
      
      console.log(`üî• Usu√°rio ${userId} selecionou plano mensal`);
      
    } catch (error) {
      console.error('‚ùå Erro no plano mensal:', error.message);
      await this.bot.sendMessage(chatId, '‚ùå Erro interno. Tente novamente.');
    }
  }

  async handlePlanYear(chatId, userId) {
    try {
      const user = await database.getUserByTelegramId(userId);
      
      if (!user) {
        await this.bot.sendMessage(chatId, '‚ùå Usu√°rio n√£o encontrado. Use /start primeiro.');
        return;
      }

      await this.bot.sendMessage(chatId, 
        'üíé **PLANO ANUAL - R$ 145,00**\n\n' +
        'üèÜ 365 dias de acesso total\n' +
        'üì± Conte√∫do premium ilimitado\n' +
        'üéØ Suporte priorit√°rio VIP\n' +
        'üí∞ **ECONOMIA DE R$ 275,00** vs mensal\n' +
        'üéÅ **MELHOR OFERTA DISPON√çVEL**\n\n' +
        'üí≥ **Clique no link abaixo para pagar:**',
        {
          parse_mode: 'Markdown',
          reply_markup: {
            inline_keyboard: [
              [
                 { text: 'üí≥ Pagar R$ 145,00 - 1 Ano', url: process.env.PLAN_YEAR_LINK }
               ],
              [
                { text: 'üîô Voltar aos Planos', callback_data: 'subscribe_now' }
              ]
            ]
          }
        }
      );
      
      console.log(`üíé Usu√°rio ${userId} selecionou plano anual`);
      
    } catch (error) {
      console.error('‚ùå Erro no plano anual:', error.message);
      await this.bot.sendMessage(chatId, '‚ùå Erro interno. Tente novamente.');
    }
  }

  // Comando admin: listar assinantes
  async handleAssinantes(msg) {
    try {
      const userId = msg.from.id;
      
      if (!this.isAdmin(userId)) {
        await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado. Comando apenas para administradores.');
        return;
      }
      
      const users = await database.getAllUsers();
      
      if (users.length === 0) {
        await this.bot.sendMessage(msg.chat.id, 'üìù Nenhum usu√°rio cadastrado.');
        return;
      }
      
      const activeUsers = users.filter(u => u.status === 'active');
      const inactiveUsers = users.filter(u => u.status !== 'active');
      
      let message = `üë• *Relat√≥rio de Assinantes*\n\n`;
      message += `üìä *Resumo:*\n`;
      message += `‚Ä¢ Total: ${users.length}\n`;
      message += `‚Ä¢ Ativos: ${activeUsers.length}\n`;
      message += `‚Ä¢ Inativos: ${inactiveUsers.length}\n\n`;
      
      if (activeUsers.length > 0) {
        message += `‚úÖ *Assinantes Ativos:*\n`;
        activeUsers.slice(0, 10).forEach(user => {
          const endDate = moment(user.subscription_end).format('DD/MM');
          message += `‚Ä¢ ${user.first_name} (@${user.username || 'sem_username'}) - at√© ${endDate}\n`;
        });
        
        if (activeUsers.length > 10) {
          message += `... e mais ${activeUsers.length - 10} usu√°rios\n`;
        }
      }
      
      await this.bot.sendMessage(msg.chat.id, message, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('‚ùå Erro no comando /assinantes:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro ao buscar assinantes.');
    }
  }

  // Comando admin: reenviar cobran√ßa
  async handleReenviar(msg, match) {
    try {
      const userId = msg.from.id;
      
      if (!this.isAdmin(userId)) {
        await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
        return;
      }
      
      const username = match[1].replace('@', '');
      
      // Busca usu√°rio por username (implementa√ß√£o simplificada)
      const users = await database.getAllUsers();
      const targetUser = users.find(u => u.username === username);
      
      if (!targetUser) {
        await this.bot.sendMessage(msg.chat.id, `‚ùå Usu√°rio @${username} n√£o encontrado.`);
        return;
      }
      
      // Gera nova cobran√ßa
      await this.handleSubscription(targetUser.telegram_id, targetUser.telegram_id);
      
      await this.bot.sendMessage(msg.chat.id, `‚úÖ Cobran√ßa reenviada para @${username}`);
      
    } catch (error) {
      console.error('‚ùå Erro no comando /reenviar:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro ao reenviar cobran√ßa.');
    }
  }

  // Comando admin: estat√≠sticas
  async handleStats(msg) {
    try {
      const userId = msg.from.id;
      
      if (!this.isAdmin(userId)) {
        await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
        return;
      }
      
      const users = await database.getAllUsers();
      const activeUsers = users.filter(u => u.status === 'active');
      const expiredUsers = users.filter(u => u.status === 'expired');
      const inactiveUsers = users.filter(u => u.status === 'inactive');
      
      // Calcula receita mensal estimada
      const monthlyRevenue = activeUsers.length * (parseInt(process.env.SUBSCRIPTION_PRICE) || 4990);
      const revenueFormatted = infinitePayService.formatCurrency(monthlyRevenue);
      
      const message = `
üìà *Estat√≠sticas do Bot*

üë• *Usu√°rios:*
‚Ä¢ Total: ${users.length}
‚Ä¢ Ativos: ${activeUsers.length}
‚Ä¢ Expirados: ${expiredUsers.length}
‚Ä¢ Inativos: ${inactiveUsers.length}

üí∞ *Financeiro:*
‚Ä¢ Receita mensal: ${revenueFormatted}
‚Ä¢ Taxa de convers√£o: ${users.length > 0 ? Math.round((activeUsers.length / users.length) * 100) : 0}%

üìÖ *Per√≠odo:* ${moment().format('DD/MM/YYYY HH:mm')}`;
      
      await this.bot.sendMessage(msg.chat.id, message, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('‚ùå Erro no comando /stats:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro ao gerar estat√≠sticas.');
    }
  }

  // Processa confirma√ß√£o de pagamento via webhook
  async processPaymentConfirmation(webhookData) {
    try {
      const { charge_id, status, paid_at } = webhookData;
      
      console.log(`üí≥ Processando pagamento: ${charge_id} - ${status}`);
      
      // Atualiza status do pagamento no banco
      await database.updatePaymentStatus(charge_id, status, paid_at);
      
      if (status === 'paid') {
        // Busca dados do pagamento
        const payment = await this.getPaymentByInfinitePayId(charge_id);
        
        if (payment) {
          // Ativa assinatura do usu√°rio
          const subscriptionEnd = moment().add(1, 'month').format('YYYY-MM-DD HH:mm:ss');
          await database.updateUserSubscription(payment.telegram_id, 'active', subscriptionEnd);
          
          // Notifica usu√°rio
          await this.notifyPaymentConfirmed(payment.telegram_id, subscriptionEnd);
        }
      }
    } catch (error) {
      console.error('‚ùå Erro ao processar confirma√ß√£o de pagamento:', error.message);
    }
  }

  // Busca pagamento por ID da InfinitePay (m√©todo auxiliar)
  async getPaymentByInfinitePayId(infinitepayId) {
    return new Promise((resolve, reject) => {
      const sql = 'SELECT * FROM payments WHERE infinitepay_id = ?';
      database.db.get(sql, [infinitepayId], (err, row) => {
        if (err) reject(err);
        else resolve(row);
      });
    });
  }

  // Notifica usu√°rio sobre pagamento confirmado
  async notifyPaymentConfirmed(telegramId, subscriptionEnd) {
    try {
      const endDate = moment(subscriptionEnd).format('DD/MM/YYYY');
      
      const message = `
‚úÖ *Pagamento Confirmado!*

üéâ Sua assinatura foi ativada com sucesso!

üìÖ *V√°lida at√©:* ${endDate}

üöÄ Agora voc√™ tem acesso completo ao conte√∫do premium!

üí° Use /start para ver suas op√ß√µes.`;
      
      await this.bot.sendMessage(telegramId, message, { parse_mode: 'Markdown' });
      
      console.log(`‚úÖ Usu√°rio ${telegramId} notificado sobre pagamento confirmado`);
    } catch (error) {
      console.error('‚ùå Erro ao notificar usu√°rio:', error.message);
    }
  }

  // Envia cobran√ßa de renova√ß√£o
  async sendRenewalCharge(telegramId) {
    try {
      const user = await database.getUserByTelegramId(telegramId);
      
      if (!user) {
        console.error(`‚ùå Usu√°rio ${telegramId} n√£o encontrado para renova√ß√£o`);
        return;
      }
      
      await this.handleSubscription(telegramId, telegramId);
      
      const message = `
üîî *Renova√ß√£o da Assinatura*

‚è∞ Sua assinatura est√° pr√≥xima do vencimento.

üí≥ Uma nova cobran√ßa foi gerada para renova√ß√£o autom√°tica.

üì± Efetue o pagamento para manter seu acesso ativo.`;
      
      await this.bot.sendMessage(telegramId, message, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('‚ùå Erro ao enviar cobran√ßa de renova√ß√£o:', error.message);
    }
  }

  // Novos m√©todos administrativos
  async handleGroups(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const groups = await this.groupManager.getGroups();
      let message = 'üìã *Grupos Cadastrados:*\n\n';
      
      if (groups.length === 0) {
        message += 'Nenhum grupo cadastrado.';
      } else {
        groups.forEach(group => {
          message += `‚Ä¢ ${group.title} (${group.telegram_id})\n`;
          message += `  Membros: ${group.member_count || 0}\n\n`;
        });
      }
      
      await this.bot.sendMessage(msg.chat.id, message, { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('‚ùå Erro ao listar grupos:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro ao listar grupos.');
    }
  }

  async handleStartScraping(msg, match) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const groupId = match[1];
      await this.bot.sendMessage(msg.chat.id, 'üîÑ Iniciando scraping...');
      
      const result = await this.groupManager.startScraping(groupId);
      
      if (result.success) {
        await this.bot.sendMessage(msg.chat.id, `‚úÖ Scraping iniciado para o grupo ${groupId}`);
      } else {
        await this.bot.sendMessage(msg.chat.id, `‚ùå Erro: ${result.error}`);
      }
    } catch (error) {
      console.error('‚ùå Erro ao iniciar scraping:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro ao iniciar scraping.');
    }
  }

  async handleAddGroup(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      await this.bot.sendMessage(msg.chat.id, 
        '‚ûï **Adicionar Novo Grupo**\n\n' +
        'Para adicionar um grupo, use o comando:\n' +
        '`/addgrupo <identificador> <nome>`\n\n' +
        '**Exemplos:**\n' +
        '‚Ä¢ `/addgrupo @meugrupo Meu Grupo`\n' +
        '‚Ä¢ `/addgrupo https://t.me/meugrupo Meu Grupo`\n' +
        '‚Ä¢ `/addgrupo -1001234567890 Meu Grupo`\n\n' +
        '**Identificadores v√°lidos:**\n' +
        '‚Ä¢ @nomegrupo\n' +
        '‚Ä¢ https://t.me/nomegrupo\n' +
        '‚Ä¢ ID num√©rico do grupo',
        { parse_mode: 'Markdown' }
      );
    } catch (error) {
      console.error('‚ùå Erro ao mostrar instru√ß√µes de adicionar grupo:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro interno.');
    }
  }

  async handleAddGroupWithIdentifier(msg, match) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const identifier = match[1];
      const groupName = match[2];
      
      // Valida o identificador
      if (!this.identifierResolver.isValidIdentifier(identifier, 'group')) {
        await this.bot.sendMessage(msg.chat.id, '‚ùå Identificador inv√°lido. Use:\n‚Ä¢ @nomegrupo\n‚Ä¢ https://t.me/nomegrupo\n‚Ä¢ ID num√©rico');
        return;
      }
      
      await this.bot.sendMessage(msg.chat.id, 'üîÑ Resolvendo identificador do grupo...');
      
      const groupInfo = await this.identifierResolver.resolveGroup(identifier);
      
      if (!groupInfo) {
        await this.bot.sendMessage(msg.chat.id, '‚ùå Grupo n√£o encontrado ou n√£o acess√≠vel.');
        return;
      }
      
      // Adiciona o grupo ao banco de dados
      const result = await this.groupManager.addGroup(groupInfo.id, groupName, groupInfo.username);
      
      if (result.success) {
        const formattedInfo = this.identifierResolver.formatIdentifier(groupInfo);
        await this.bot.sendMessage(msg.chat.id, 
          `‚úÖ Grupo adicionado com sucesso!\n\n` +
          `üìã **Informa√ß√µes:**\n` +
          `‚Ä¢ Nome: ${groupName}\n` +
          `‚Ä¢ Grupo: ${formattedInfo}\n` +
          `‚Ä¢ Membros: ${groupInfo.member_count}\n` +
          `‚Ä¢ Tipo: ${groupInfo.type}`, 
          { parse_mode: 'Markdown' }
        );
      } else {
        await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao adicionar grupo: ${result.error}`);
      }
    } catch (error) {
      console.error('‚ùå Erro ao adicionar grupo:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro interno ao adicionar grupo.');
    }
  }

  async handleUserInfo(msg, match) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const identifier = match[1];
      
      if (!this.identifierResolver.isValidIdentifier(identifier, 'user')) {
        await this.bot.sendMessage(msg.chat.id, '‚ùå Identificador de usu√°rio inv√°lido. Use:\n‚Ä¢ @username\n‚Ä¢ ID num√©rico');
        return;
      }
      
      await this.bot.sendMessage(msg.chat.id, 'üîÑ Buscando informa√ß√µes do usu√°rio...');
      
      const userInfo = await this.identifierResolver.resolveUser(identifier);
      
      if (!userInfo) {
        await this.bot.sendMessage(msg.chat.id, '‚ùå Usu√°rio n√£o encontrado ou n√£o acess√≠vel.');
        return;
      }
      
      const formattedInfo = this.identifierResolver.formatIdentifier(userInfo);
      
      await this.bot.sendMessage(msg.chat.id, 
        `üë§ **Informa√ß√µes do Usu√°rio:**\n\n` +
        `‚Ä¢ ${formattedInfo}\n` +
        `‚Ä¢ ID: \`${userInfo.id}\`\n` +
        `‚Ä¢ Username: ${userInfo.username ? `@${userInfo.username}` : 'N√£o definido'}\n` +
        `‚Ä¢ Nome: ${userInfo.first_name || 'N√£o definido'}\n` +
        `‚Ä¢ Sobrenome: ${userInfo.last_name || 'N√£o definido'}`, 
        { parse_mode: 'Markdown' }
      );
    } catch (error) {
      console.error('‚ùå Erro ao buscar usu√°rio:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro interno ao buscar usu√°rio.');
    }
  }

  async handleGroupInfo(msg, match) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const identifier = match[1];
      
      if (!this.identifierResolver.isValidIdentifier(identifier, 'group')) {
        await this.bot.sendMessage(msg.chat.id, '‚ùå Identificador de grupo inv√°lido. Use:\n‚Ä¢ @nomegrupo\n‚Ä¢ https://t.me/nomegrupo\n‚Ä¢ ID num√©rico');
        return;
      }
      
      await this.bot.sendMessage(msg.chat.id, 'üîÑ Buscando informa√ß√µes do grupo...');
      
      const groupInfo = await this.identifierResolver.resolveGroup(identifier);
      
      if (!groupInfo) {
        await this.bot.sendMessage(msg.chat.id, '‚ùå Grupo n√£o encontrado ou n√£o acess√≠vel.');
        return;
      }
      
      const formattedInfo = this.identifierResolver.formatIdentifier(groupInfo);
      
      await this.bot.sendMessage(msg.chat.id, 
        `üë• **Informa√ß√µes do Grupo:**\n\n` +
        `‚Ä¢ ${formattedInfo}\n` +
        `‚Ä¢ ID: \`${groupInfo.id}\`\n` +
        `‚Ä¢ Username: ${groupInfo.username ? `@${groupInfo.username}` : 'N√£o definido'}\n` +
        `‚Ä¢ T√≠tulo: ${groupInfo.title}\n` +
        `‚Ä¢ Tipo: ${groupInfo.type}\n` +
        `‚Ä¢ Membros: ${groupInfo.member_count}`, 
        { parse_mode: 'Markdown' }
      );
    } catch (error) {
      console.error('‚ùå Erro ao buscar grupo:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro interno ao buscar grupo.');
    }
  }

  async handleGroupMembers(msg, match) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const identifier = match[1];
      
      if (!this.identifierResolver.isValidIdentifier(identifier, 'group')) {
        await this.bot.sendMessage(msg.chat.id, '‚ùå Identificador de grupo inv√°lido. Use:\n‚Ä¢ @nomegrupo\n‚Ä¢ https://t.me/nomegrupo\n‚Ä¢ ID num√©rico');
        return;
      }
      
      await this.bot.sendMessage(msg.chat.id, 'üîÑ Resolvendo grupo e buscando membros...');
      
      const groupInfo = await this.identifierResolver.resolveGroup(identifier);
      
      if (!groupInfo) {
        await this.bot.sendMessage(msg.chat.id, '‚ùå Grupo n√£o encontrado ou n√£o acess√≠vel.');
        return;
      }
      
      const members = await this.groupManager.getGroupMembers(groupInfo.id);
      const formattedInfo = this.identifierResolver.formatIdentifier(groupInfo);
      
      let message = `üë• **Membros do Grupo:**\n${formattedInfo}\n\n`;
      message += `Total: ${members.length} membros\n\n`;
      
      members.slice(0, 20).forEach(member => {
        message += `‚Ä¢ ${member.first_name || 'N/A'} (@${member.username || 'sem_username'})\n`;
      });
      
      if (members.length > 20) {
        message += `\n... e mais ${members.length - 20} membros`;
      }
      
      await this.bot.sendMessage(msg.chat.id, message, { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('‚ùå Erro ao listar membros:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro ao listar membros.');
    }
  }

  async handleReplicateMembers(msg, match) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const sourceIdentifier = match[1];
      const targetIdentifier = match[2];
      
      // Valida identificadores
      if (!this.identifierResolver.isValidIdentifier(sourceIdentifier, 'group') || 
          !this.identifierResolver.isValidIdentifier(targetIdentifier, 'group')) {
        await this.bot.sendMessage(msg.chat.id, '‚ùå Identificadores inv√°lidos. Use:\n‚Ä¢ @nomegrupo\n‚Ä¢ https://t.me/nomegrupo\n‚Ä¢ ID num√©rico');
        return;
      }
      
      await this.bot.sendMessage(msg.chat.id, 'üîÑ Resolvendo grupos...');
      
      const [sourceGroup, targetGroup] = await Promise.all([
        this.identifierResolver.resolveGroup(sourceIdentifier),
        this.identifierResolver.resolveGroup(targetIdentifier)
      ]);
      
      if (!sourceGroup || !targetGroup) {
        await this.bot.sendMessage(msg.chat.id, '‚ùå Um ou ambos os grupos n√£o foram encontrados.');
        return;
      }
      
      const sourceFormatted = this.identifierResolver.formatIdentifier(sourceGroup);
      const targetFormatted = this.identifierResolver.formatIdentifier(targetGroup);
      
      await this.bot.sendMessage(msg.chat.id, 
        `üîÑ Iniciando replica√ß√£o de membros...\n\n` +
        `üì§ **Origem:** ${sourceFormatted}\n` +
        `üì• **Destino:** ${targetFormatted}`,
        { parse_mode: 'Markdown' }
      );
      
      const result = await this.groupManager.replicateMembers(sourceGroup.id, targetGroup.id);
      
      if (result.success) {
        await this.bot.sendMessage(msg.chat.id, 
          `‚úÖ **Replica√ß√£o conclu√≠da!**\n\n` +
          `üìä **Resultado:**\n` +
          `‚Ä¢ Membros adicionados: ${result.added}\n` +
          `‚Ä¢ Origem: ${sourceFormatted}\n` +
          `‚Ä¢ Destino: ${targetFormatted}`,
          { parse_mode: 'Markdown' }
        );
      } else {
        await this.bot.sendMessage(msg.chat.id, `‚ùå Erro na replica√ß√£o: ${result.error}`);
      }
    } catch (error) {
      console.error('‚ùå Erro na replica√ß√£o:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro interno na replica√ß√£o.');
    }
  }

  async handleScrapingJobs(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const jobs = await this.groupManager.getScrapingJobs();
      
      let message = '‚öôÔ∏è *Jobs de Scraping:*\n\n';
      
      if (jobs.length === 0) {
        message += 'Nenhum job ativo.';
      } else {
        jobs.forEach(job => {
          message += `‚Ä¢ Grupo: ${job.group_id}\n`;
          message += `  Status: ${job.status}\n`;
          message += `  Progresso: ${job.progress || 0}%\n\n`;
        });
      }
      
      await this.bot.sendMessage(msg.chat.id, message, { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('‚ùå Erro ao listar jobs:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro ao listar jobs.');
    }
  }

  async handleLogs(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const logs = await this.groupManager.getLogs();
      
      let message = 'üìã *Logs Recentes:*\n\n';
      
      if (logs.length === 0) {
        message += 'Nenhum log encontrado.';
      } else {
        logs.slice(0, 10).forEach(log => {
          const date = moment(log.created_at).format('DD/MM HH:mm');
          message += `[${date}] ${log.action}: ${log.details}\n`;
        });
      }
      
      await this.bot.sendMessage(msg.chat.id, message, { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('‚ùå Erro ao buscar logs:', error.message);
      await this.bot.sendMessage(msg.chat.id, '‚ùå Erro ao buscar logs.');
    }
  }

  async handleAutoAdd(msg, match) {
     if (!this.isAdmin(msg.from.id)) {
       await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
       return;
     }
     
     try {
       const userId = match[1];
       const groupId = match[2];
       
       await this.bot.sendMessage(msg.chat.id, 'üîÑ Adicionando usu√°rio ao grupo...');
       
       const result = await this.groupManager.addMemberToGroup(userId, groupId);
       
       if (result.success) {
         await this.bot.sendMessage(msg.chat.id, `‚úÖ Usu√°rio ${userId} adicionado ao grupo ${groupId}`);
       } else {
         await this.bot.sendMessage(msg.chat.id, `‚ùå Erro: ${result.error}`);
       }
     } catch (error) {
       console.error('‚ùå Erro no auto-add:', error.message);
       await this.bot.sendMessage(msg.chat.id, '‚ùå Erro no auto-add.');
     }
   }
   
   async handleBulkAdd(msg, match) {
     if (!this.isAdmin(msg.from.id)) {
       await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
       return;
     }
     
     try {
       const groupId = match[1];
       
       // Obter membros ativos de todos os grupos para adicionar
       const allMembers = await this.groupManager.getAllActiveMembers();
       
       if (allMembers.length === 0) {
         await this.bot.sendMessage(msg.chat.id, '‚ùå Nenhum membro encontrado para adicionar.');
         return;
       }
       
       await this.bot.sendMessage(msg.chat.id, `üîÑ Iniciando adi√ß√£o em massa de ${allMembers.length} membros...`);
       
       const userIds = allMembers.map(member => member.user_id);
       const result = await this.groupManager.bulkAddMembers(userIds, groupId, {
         maxConcurrent: 3,
         delayBetweenBatches: 15000,
         useInviteLink: true
       });
       
       const message = `
 üìä *Resultado da Adi√ß√£o em Massa:*
 
 ‚úÖ Sucessos: ${result.success}
 ‚ùå Falhas: ${result.failed}
 üìà Total: ${result.success + result.failed}
 
 ${result.errors.length > 0 ? `‚ö†Ô∏è Primeiros erros:\n${result.errors.slice(0, 5).join('\n')}` : ''}`;
       
       await this.bot.sendMessage(msg.chat.id, message, { parse_mode: 'Markdown' });
     } catch (error) {
       console.error('‚ùå Erro no bulk add:', error.message);
       await this.bot.sendMessage(msg.chat.id, '‚ùå Erro no bulk add.');
     }
   }
   
   async handleAdminPanel(msg) {
     if (!this.isAdmin(msg.from.id)) {
       await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
       return;
     }
     
     const message = `üîß *Painel Administrativo*\n\nüìã Selecione uma categoria para gerenciar:`;
     
     const keyboard = {
       inline_keyboard: [
         [
           { text: 'üë• Grupos', callback_data: 'admin_grupos' },
           { text: 'üìä Estat√≠sticas', callback_data: 'admin_stats' }
         ],
         [
           { text: 'üë§ Usu√°rios', callback_data: 'admin_usuarios' },
           { text: 'üíæ Backup', callback_data: 'admin_backup' }
         ],
         [
           { text: 'ü§ñ Auto-Post', callback_data: 'admin_autopost' },
           { text: '‚öôÔ∏è Sistema', callback_data: 'admin_sistema' }
         ],
         [
           { text: 'üîß Configura√ß√µes', callback_data: 'admin_config' },
           { text: 'üìã Jobs', callback_data: 'admin_jobs' }
         ],
         [
           { text: 'üîÑ Atualizar', callback_data: 'admin_refresh' }
         ]
       ]
     };
     
     await this.bot.sendMessage(msg.chat.id, message, {
       parse_mode: 'Markdown',
       reply_markup: keyboard
     });
   }

  // === M√âTODOS DO PAINEL ADMINISTRATIVO INTERATIVO ===
  
  async handleAdminGrupos(callbackQuery) {
    const chatId = callbackQuery.message.chat.id;
    const userId = callbackQuery.from.id;
    
    if (!this.isAdmin(userId)) {
      await this.bot.sendMessage(chatId, '‚ùå Acesso negado.');
      return;
    }
    
    const message = `üë• *Gerenciamento de Grupos*\n\nEscolha uma a√ß√£o:`;
    
    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üìã Listar Grupos', callback_data: 'grupos_listar' },
          { text: 'üë• Ver Membros', callback_data: 'grupos_membros' }
        ],
        [
          { text: 'üîç Iniciar Scraping', callback_data: 'grupos_scraping' },
          { text: '‚ûï Adicionar Usu√°rio', callback_data: 'grupos_add_user' }
        ],
        [
          { text: 'üì¶ Adi√ß√£o em Massa', callback_data: 'grupos_bulk_add' },
          { text: 'üîÑ Replicar Membros', callback_data: 'grupos_replicar' }
        ],
        [
          { text: 'üìä Jobs de Scraping', callback_data: 'grupos_jobs' },
          { text: '‚ûï Adicionar Grupo', callback_data: 'grupos_add_grupo' }
        ],
        [
          { text: 'üîô Voltar', callback_data: 'admin_refresh' }
        ]
      ]
    };
    
    await this.bot.editMessageText(message, {
      chat_id: chatId,
      message_id: callbackQuery.message.message_id,
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }
  
  async handleAdminStats(callbackQuery) {
    const chatId = callbackQuery.message.chat.id;
    const userId = callbackQuery.from.id;
    
    if (!this.isAdmin(userId)) {
      await this.bot.sendMessage(chatId, '‚ùå Acesso negado.');
      return;
    }
    
    const message = `üìä *Estat√≠sticas e Monitoramento*\n\nEscolha uma op√ß√£o:`;
    
    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üìà Stats B√°sicas', callback_data: 'stats_basicas' },
          { text: 'üìä Stats Avan√ßadas', callback_data: 'stats_avancadas' }
        ],
        [
          { text: 'üë• Assinantes', callback_data: 'stats_assinantes' },
          { text: 'üí¨ DM Stats', callback_data: 'stats_dm' }
        ],
        [
          { text: 'üìã Logs Recentes', callback_data: 'stats_logs' },
          { text: '‚öôÔ∏è Info Sistema', callback_data: 'stats_sistema' }
        ],
        [
          { text: 'üîô Voltar', callback_data: 'admin_refresh' }
        ]
      ]
    };
    
    await this.bot.editMessageText(message, {
      chat_id: chatId,
      message_id: callbackQuery.message.message_id,
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }
  
  async handleAdminUsuarios(callbackQuery) {
    const chatId = callbackQuery.message.chat.id;
    const userId = callbackQuery.from.id;
    
    if (!this.isAdmin(userId)) {
      await this.bot.sendMessage(chatId, '‚ùå Acesso negado.');
      return;
    }
    
    const message = `üë§ *Gerenciamento de Usu√°rios*\n\nEscolha uma a√ß√£o:`;
    
    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üìã Listar Usu√°rios', callback_data: 'users_listar' },
          { text: 'üö´ Banir Usu√°rio', callback_data: 'users_ban' }
        ],
        [
          { text: '‚úÖ Desbanir Usu√°rio', callback_data: 'users_unban' },
          { text: 'üîç Buscar Usu√°rio', callback_data: 'users_buscar' }
        ],
        [
          { text: 'üîô Voltar', callback_data: 'admin_refresh' }
        ]
      ]
    };
    
    await this.bot.editMessageText(message, {
      chat_id: chatId,
      message_id: callbackQuery.message.message_id,
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }
  
  async handleAdminBackup(callbackQuery) {
    const chatId = callbackQuery.message.chat.id;
    const userId = callbackQuery.from.id;
    
    if (!this.isAdmin(userId)) {
      await this.bot.sendMessage(chatId, '‚ùå Acesso negado.');
      return;
    }
    
    const message = `üíæ *Backup e Replica√ß√£o*\n\nEscolha uma a√ß√£o:`;
    
    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üíæ Criar Backup', callback_data: 'backup_criar' },
          { text: 'üìã Listar Backups', callback_data: 'backup_listar' }
        ],
        [
          { text: 'üîÑ Restaurar Backup', callback_data: 'backup_restaurar' },
          { text: 'üóëÔ∏è Limpar Backups', callback_data: 'backup_limpar' }
        ],
        [
          { text: 'üîô Voltar', callback_data: 'admin_refresh' }
        ]
      ]
    };
    
    await this.bot.editMessageText(message, {
      chat_id: chatId,
      message_id: callbackQuery.message.message_id,
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }
  
  async handleAdminAutoPost(callbackQuery) {
    const chatId = callbackQuery.message.chat.id;
    const userId = callbackQuery.from.id;
    
    if (!this.isAdmin(userId)) {
      await this.bot.sendMessage(chatId, '‚ùå Acesso negado.');
      return;
    }
    
    const message = `ü§ñ *Auto-Post e IA*\n\nEscolha uma a√ß√£o:`;
    
    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üìä Status Auto-Post', callback_data: 'autopost_status' },
          { text: '‚ñ∂Ô∏è Iniciar Auto-Post', callback_data: 'autopost_start' }
        ],
        [
          { text: '‚èπÔ∏è Parar Auto-Post', callback_data: 'autopost_stop' },
          { text: 'üîÑ Toggle Grupo', callback_data: 'autopost_toggle' }
        ],
        [
          { text: 'ü§ñ Testar IA', callback_data: 'autopost_test_ai' },
          { text: 'üí¨ Stats DM', callback_data: 'autopost_dm_stats' }
        ],
        [
          { text: 'üîô Voltar', callback_data: 'admin_refresh' }
        ]
      ]
    };
    
    await this.bot.editMessageText(message, {
      chat_id: chatId,
      message_id: callbackQuery.message.message_id,
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }
  
  async handleAdminSistema(callbackQuery) {
    const chatId = callbackQuery.message.chat.id;
    const userId = callbackQuery.from.id;
    
    if (!this.isAdmin(userId)) {
      await this.bot.sendMessage(chatId, '‚ùå Acesso negado.');
      return;
    }
    
    const message = `‚öôÔ∏è *Informa√ß√µes do Sistema*\n\nEscolha uma op√ß√£o:`;
    
    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üíª Info Sistema', callback_data: 'sistema_info' },
          { text: 'üìä Estat√≠sticas', callback_data: 'sistema_stats' }
        ],
        [
          { text: 'üìã Logs Sistema', callback_data: 'sistema_logs' },
          { text: 'üîÑ Status Servi√ßos', callback_data: 'sistema_status' }
        ],
        [
          { text: 'üîô Voltar', callback_data: 'admin_refresh' }
        ]
      ]
    };
    
    await this.bot.editMessageText(message, {
      chat_id: chatId,
      message_id: callbackQuery.message.message_id,
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }
  
  async handleAdminConfig(callbackQuery) {
    const chatId = callbackQuery.message.chat.id;
    const userId = callbackQuery.from.id;
    
    if (!this.isAdmin(userId)) {
      await this.bot.sendMessage(chatId, '‚ùå Acesso negado.');
      return;
    }
    
    const message = `üîß *Configura√ß√µes*\n\nEscolha uma a√ß√£o:`;
    
    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üìã Ver Configura√ß√µes', callback_data: 'config_ver' },
          { text: '‚úèÔ∏è Alterar Config', callback_data: 'config_alterar' }
        ],
        [
          { text: 'üîÑ Resetar Config', callback_data: 'config_reset' },
          { text: 'üíæ Backup Config', callback_data: 'config_backup' }
        ],
        [
          { text: 'üîô Voltar', callback_data: 'admin_refresh' }
        ]
      ]
    };
    
    await this.bot.editMessageText(message, {
      chat_id: chatId,
      message_id: callbackQuery.message.message_id,
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }
  
  async handleAdminJobs(callbackQuery) {
    const chatId = callbackQuery.message.chat.id;
    const userId = callbackQuery.from.id;
    
    if (!this.isAdmin(userId)) {
      await this.bot.sendMessage(chatId, '‚ùå Acesso negado.');
      return;
    }
    
    const message = `üìã *Gerenciamento de Jobs*\n\nEscolha uma a√ß√£o:`;
    
    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üìã Jobs Ativos', callback_data: 'jobs_ativos' },
          { text: 'üìä Jobs Scraping', callback_data: 'jobs_scraping' }
        ],
        [
          { text: '‚èπÔ∏è Parar Job', callback_data: 'jobs_parar' },
          { text: 'üîÑ Reiniciar Job', callback_data: 'jobs_reiniciar' }
        ],
        [
          { text: 'üîô Voltar', callback_data: 'admin_refresh' }
        ]
      ]
    };
    
    await this.bot.editMessageText(message, {
      chat_id: chatId,
      message_id: callbackQuery.message.message_id,
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }

  // === M√âTODOS DE BACKUP E REPLICA√á√ÉO ===
  
  async handleBackup(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const loadingMsg = await this.bot.sendMessage(msg.chat.id, 'üîÑ Criando backup completo...');
      
      const backupFile = await this.backupManager.createFullBackup();
      const backups = await this.backupManager.listBackups();
      
      const fileName = this.escapeMarkdown(require('path').basename(backupFile));
      
      let response = `‚úÖ *Backup criado com sucesso!*\n\n`;
      response += `üìÅ Arquivo: \`${fileName}\`\n`;
      response += `üìä Total de backups: ${backups.length}\n\n`;
      response += `*Backups recentes:*\n`;
      
      backups.slice(0, 5).forEach(backup => {
        const escapedFilename = this.escapeMarkdown(backup.filename);
        response += `‚Ä¢ ${escapedFilename} (${backup.age_days} dias)\n`;
      });
      
      await this.bot.editMessageText(response, {
        chat_id: msg.chat.id,
        message_id: loadingMsg.message_id,
        parse_mode: 'Markdown'
      });
      
    } catch (error) {
      console.error('Erro no backup:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao criar backup: ${error.message}`);
    }
  }
  
  async handleReplicate(msg, match) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    const sourceGroupId = match[1];
    const targetGroupId = match[2];
    const maxMembers = 100;
    
    try {
      const loadingMsg = await this.bot.sendMessage(msg.chat.id, 'üîÑ Iniciando replica√ß√£o de membros...');
      
      const result = await this.backupManager.replicateMembers(sourceGroupId, targetGroupId, {
        maxMembers,
        onlyActive: true,
        excludeAdmins: true,
        delayBetweenAdds: 3000,
        onProgress: async (progress) => {
          if (progress.current % 10 === 0) {
            const progressText = `üîÑ **Replicando membros...**\n\n` +
              `üìä Progresso: ${progress.current}/${progress.total} (${progress.progress}%)\n` +
              `‚úÖ Sucessos: ${progress.success}\n` +
              `‚ùå Falhas: ${progress.failed}`;
            
            try {
              await this.bot.editMessageText(progressText, {
                chat_id: msg.chat.id,
                message_id: loadingMsg.message_id,
                parse_mode: 'Markdown'
              });
            } catch (e) {
              // Ignora erros de edi√ß√£o
            }
          }
        }
      });
      
      let response = `‚úÖ **Replica√ß√£o conclu√≠da!**\n\n`;
      response += `üìä **Resultados:**\n`;
      response += `‚Ä¢ Total processados: ${result.total}\n`;
      response += `‚Ä¢ Sucessos: ${result.success}\n`;
      response += `‚Ä¢ Falhas: ${result.failed}\n`;
      response += `‚Ä¢ Taxa de sucesso: ${((result.success / result.total) * 100).toFixed(1)}%\n\n`;
      response += `üÜî Job ID: ${result.job_id}`;
      
      await this.bot.editMessageText(response, {
        chat_id: msg.chat.id,
        message_id: loadingMsg.message_id,
        parse_mode: 'Markdown'
      });
      
    } catch (error) {
      console.error('Erro na replica√ß√£o:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro na replica√ß√£o: ${error.message}`);
    }
  }
  
  async handleRestore(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const backups = await this.backupManager.listBackups();
      
      if (backups.length === 0) {
        return await this.bot.sendMessage(msg.chat.id, '‚ùå Nenhum backup encontrado.');
      }
      
      let response = `üìã **Backups dispon√≠veis:**\n\n`;
      
      backups.slice(0, 10).forEach((backup, index) => {
        const sizeKB = (backup.size / 1024).toFixed(1);
        response += `${index + 1}. \`${backup.filename}\`\n`;
        response += `   üìÖ ${backup.created.toLocaleDateString('pt-BR')}\n`;
        response += `   üì¶ ${sizeKB} KB (${backup.age_days} dias)\n\n`;
      });
      
      response += `‚ö†Ô∏è **Aten√ß√£o:** Restaura√ß√£o ainda em desenvolvimento.\n`;
      response += `Use \`/backup\` para criar novos backups.`;
      
      await this.bot.sendMessage(msg.chat.id, response, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('Erro ao listar backups:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao listar backups: ${error.message}`);
    }
  }
  
  async handleCleanup(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    const args = msg.text.split(' ');
    const daysToKeep = parseInt(args[1]) || 30;
    
    try {
      const loadingMsg = await this.bot.sendMessage(msg.chat.id, `üßπ Limpando backups com mais de ${daysToKeep} dias...`);
      
      const removedCount = await this.backupManager.cleanOldBackups(daysToKeep);
      const remainingBackups = await this.backupManager.listBackups();
      
      let response = `‚úÖ **Limpeza conclu√≠da!**\n\n`;
      response += `üóëÔ∏è Backups removidos: ${removedCount}\n`;
      response += `üìÅ Backups restantes: ${remainingBackups.length}\n\n`;
      
      if (remainingBackups.length > 0) {
        response += `**Backups mais recentes:**\n`;
        remainingBackups.slice(0, 3).forEach(backup => {
          response += `‚Ä¢ ${backup.filename} (${backup.age_days} dias)\n`;
        });
      }
      
      await this.bot.editMessageText(response, {
        chat_id: msg.chat.id,
        message_id: loadingMsg.message_id,
        parse_mode: 'Markdown'
      });
      
    } catch (error) {
       console.error('Erro na limpeza:', error);
       await this.bot.sendMessage(msg.chat.id, `‚ùå Erro na limpeza: ${error.message}`);
     }
   }

  // === COMANDOS ADMINISTRATIVOS AVAN√áADOS ===
  
  async handleConfig(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const settings = await database.getAllSettings();
      
      let response = `‚öôÔ∏è **Configura√ß√µes do Sistema**\n\n`;
      
      if (settings.length === 0) {
        response += `‚ÑπÔ∏è Nenhuma configura√ß√£o encontrada.\n\n`;
        response += `**Configura√ß√µes padr√£o:**\n`;
        response += `‚Ä¢ Rate limit: 30 segundos\n`;
        response += `‚Ä¢ Max membros por job: 100\n`;
        response += `‚Ä¢ Backup autom√°tico: 24h\n`;
      } else {
        settings.forEach(setting => {
          response += `‚Ä¢ **${setting.key}**: \`${setting.value}\`\n`;
          if (setting.description) {
            response += `  _${setting.description}_\n`;
          }
          response += `\n`;
        });
      }
      
      response += `**Comandos:**\n`;
      response += `‚Ä¢ \`/set <chave> <valor>\` - Alterar configura√ß√£o\n`;
      response += `‚Ä¢ \`/config\` - Ver configura√ß√µes atuais`;
      
      await this.bot.sendMessage(msg.chat.id, response, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('Erro ao buscar configura√ß√µes:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao buscar configura√ß√µes: ${error.message}`);
    }
  }
  
  async handleSetConfig(msg, match) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    const key = match[1];
    const value = match[2];
    
    try {
      // Valida√ß√µes b√°sicas
      const allowedKeys = [
        'rate_limit_seconds',
        'max_members_per_job',
        'backup_interval_hours',
        'auto_backup_enabled',
        'scraping_delay_ms',
        'max_concurrent_jobs'
      ];
      
      if (!allowedKeys.includes(key)) {
        return await this.bot.sendMessage(msg.chat.id, 
          `‚ùå Chave inv√°lida. Chaves permitidas:\n${allowedKeys.map(k => `‚Ä¢ ${k}`).join('\n')}`);
      }
      
      // Determina o tipo baseado na chave
      let type = 'string';
      if (key.includes('_seconds') || key.includes('_hours') || key.includes('_ms') || key.includes('max_')) {
        type = 'number';
      } else if (key.includes('_enabled')) {
        type = 'boolean';
      }
      
      await database.saveSetting(key, value, type, `Configurado via bot em ${new Date().toLocaleString('pt-BR')}`);
      
      await this.bot.sendMessage(msg.chat.id, 
        `‚úÖ **Configura√ß√£o atualizada!**\n\n‚Ä¢ **${key}**: \`${value}\`\n\nUse \`/config\` para ver todas as configura√ß√µes.`, 
        { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('Erro ao salvar configura√ß√£o:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao salvar configura√ß√£o: ${error.message}`);
    }
  }
  
  async handleAdvancedStats(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const loadingMsg = await this.bot.sendMessage(msg.chat.id, 'üìä Gerando estat√≠sticas avan√ßadas...');
      
      // Gera estat√≠sticas do dia
      const todayStats = await database.generateTodayStats();
      
      // Busca estat√≠sticas dos √∫ltimos 7 dias
      const weekAgo = new Date();
      weekAgo.setDate(weekAgo.getDate() - 7);
      const weekStats = await database.getDailyStats(weekAgo.toISOString().split('T')[0]);
      
      let response = `üìä **Estat√≠sticas Avan√ßadas**\n\n`;
      
      response += `**üìÖ Hoje (${new Date().toLocaleDateString('pt-BR')}):**\n`;
      response += `‚Ä¢ üë• Usu√°rios totais: ${todayStats.total_users}\n`;
      response += `‚Ä¢ ‚úÖ Usu√°rios ativos: ${todayStats.active_users}\n`;
      response += `‚Ä¢ üì± Grupos totais: ${todayStats.total_groups}\n`;
      response += `‚Ä¢ üîÑ Jobs de scraping: ${todayStats.scraping_jobs}\n`;
      response += `‚Ä¢ üí∞ Receita: R$ ${(todayStats.revenue / 100).toFixed(2)}\n\n`;
      
      if (weekStats.length > 1) {
        const totalRevenue = weekStats.reduce((sum, day) => sum + (day.revenue || 0), 0);
        const totalNewMembers = weekStats.reduce((sum, day) => sum + (day.new_members || 0), 0);
        const totalJobs = weekStats.reduce((sum, day) => sum + (day.scraping_jobs || 0), 0);
        
        response += `**üìà √öltimos 7 dias:**\n`;
        response += `‚Ä¢ üí∞ Receita total: R$ ${(totalRevenue / 100).toFixed(2)}\n`;
        response += `‚Ä¢ üë• Novos membros: ${totalNewMembers}\n`;
        response += `‚Ä¢ üîÑ Jobs executados: ${totalJobs}\n`;
        response += `‚Ä¢ üìä M√©dia di√°ria: R$ ${(totalRevenue / 7 / 100).toFixed(2)}\n\n`;
      }
      
      response += `**üîß Sistema:**\n`;
      response += `‚Ä¢ ‚è∞ Uptime: ${process.uptime().toFixed(0)}s\n`;
      response += `‚Ä¢ üíæ Mem√≥ria: ${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(1)} MB\n`;
      response += `‚Ä¢ ü§ñ Vers√£o Node: ${process.version}`;
      
      await this.bot.editMessageText(response, {
        chat_id: msg.chat.id,
        message_id: loadingMsg.message_id,
        parse_mode: 'Markdown'
      });
      
    } catch (error) {
      console.error('Erro ao gerar estat√≠sticas:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao gerar estat√≠sticas: ${error.message}`);
    }
  }
  
  async handleSystemInfo(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const uptime = process.uptime();
      const memory = process.memoryUsage();
      
      let response = `üñ•Ô∏è **Informa√ß√µes do Sistema**\n\n`;
      
      response += `**‚ö° Performance:**\n`;
      response += `‚Ä¢ Uptime: ${Math.floor(uptime / 3600)}h ${Math.floor((uptime % 3600) / 60)}m\n`;
      response += `‚Ä¢ Mem√≥ria usada: ${(memory.heapUsed / 1024 / 1024).toFixed(1)} MB\n`;
      response += `‚Ä¢ Mem√≥ria total: ${(memory.heapTotal / 1024 / 1024).toFixed(1)} MB\n`;
      response += `‚Ä¢ CPU: ${process.cpuUsage().user}Œºs\n\n`;
      
      response += `**üîß Ambiente:**\n`;
      response += `‚Ä¢ Node.js: ${process.version}\n`;
      response += `‚Ä¢ Plataforma: ${process.platform}\n`;
      response += `‚Ä¢ Arquitetura: ${process.arch}\n\n`;
      
      response += `**üìä Bot:**\n`;
      response += `‚Ä¢ Admins configurados: ${this.adminIds.length}\n`;
      response += `‚Ä¢ Polling ativo: ‚úÖ\n`;
      response += `‚Ä¢ Backup autom√°tico: ‚è∞`;
      
      await this.bot.sendMessage(msg.chat.id, response, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('Erro ao buscar info do sistema:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao buscar informa√ß√µes: ${error.message}`);
    }
  }
  
  async handleUsers(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const users = await database.all(`
        SELECT telegram_id, username, first_name, status, 
               subscription_end, created_at, is_active
        FROM users 
        ORDER BY created_at DESC 
        LIMIT 20
      `);
      
      let response = `üë• **Usu√°rios Recentes (${users.length})**\n\n`;
      
      users.forEach((user, index) => {
        const status = user.status === 'active' ? '‚úÖ' : user.status === 'expired' ? '‚è∞' : '‚ùå';
        const name = user.first_name || user.username || 'Sem nome';
        const created = new Date(user.created_at).toLocaleDateString('pt-BR');
        
        response += `${index + 1}. ${status} **${name}**\n`;
        response += `   ID: \`${user.telegram_id}\`\n`;
        response += `   Status: ${user.status}\n`;
        response += `   Criado: ${created}\n\n`;
      });
      
      response += `**Comandos:**\n`;
      response += `‚Ä¢ \`/ban <user_id>\` - Banir usu√°rio\n`;
      response += `‚Ä¢ \`/unban <user_id>\` - Desbanir usu√°rio`;
      
      await this.bot.sendMessage(msg.chat.id, response, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('Erro ao listar usu√°rios:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao listar usu√°rios: ${error.message}`);
    }
  }
  
  async handleBanUser(msg, match) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    const userId = match[1];
    
    try {
      await database.run('UPDATE users SET is_active = 0, status = "banned" WHERE telegram_id = ?', [userId]);
      
      await database.saveActionLog('user_banned', userId, null, {
        banned_by: msg.from.id,
        reason: 'Banido via comando admin'
      });
      
      await this.bot.sendMessage(msg.chat.id, 
        `‚úÖ **Usu√°rio banido!**\n\n‚Ä¢ ID: \`${userId}\`\n‚Ä¢ A√ß√£o: Banimento\n‚Ä¢ Admin: ${msg.from.first_name}`, 
        { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('Erro ao banir usu√°rio:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao banir usu√°rio: ${error.message}`);
    }
  }
  
  async handleUnbanUser(msg, match) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    const userId = match[1];
    
    try {
      await database.run('UPDATE users SET is_active = 1, status = "inactive" WHERE telegram_id = ?', [userId]);
      
      await database.saveActionLog('user_unbanned', userId, null, {
        unbanned_by: msg.from.id,
        reason: 'Desbanido via comando admin'
      });
      
      await this.bot.sendMessage(msg.chat.id, 
        `‚úÖ **Usu√°rio desbanido!**\n\n‚Ä¢ ID: \`${userId}\`\n‚Ä¢ A√ß√£o: Desbloqueio\n‚Ä¢ Admin: ${msg.from.first_name}`, 
        { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('Erro ao desbanir usu√°rio:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao desbanir usu√°rio: ${error.message}`);
    }
  }

  // Capturar novos membros automaticamente
  async handleNewChatMembers(msg) {
    try {
      const groupId = msg.chat.id.toString();
      const groupName = msg.chat.title || 'Grupo sem nome';
      
      // Salvar informa√ß√µes do grupo
      await this.groupManager.saveGroup({
        telegram_id: groupId,
        title: groupName,
        type: msg.chat.type,
        member_count: await this.getChatMemberCount(groupId)
      });
      
      // Salvar cada novo membro
      for (const member of msg.new_chat_members) {
        if (!member.is_bot) {
          await this.groupManager.saveMember({
            user_id: member.id.toString(),
            group_id: groupId,
            username: member.username,
            first_name: member.first_name,
            last_name: member.last_name,
            is_active: true
          });
          
          console.log(`‚úÖ Novo membro capturado: ${member.first_name} (${member.id}) no grupo ${groupName}`);
        }
      }
    } catch (error) {
      console.error('‚ùå Erro ao capturar novos membros:', error.message);
    }
  }
  
  async handleLeftChatMember(msg) {
    try {
      const groupId = msg.chat.id.toString();
      const userId = msg.left_chat_member.id.toString();
      
      // Marcar membro como inativo
      await this.groupManager.updateMemberStatus(userId, groupId, false);
      
      console.log(`üëã Membro saiu: ${msg.left_chat_member.first_name} (${userId}) do grupo ${msg.chat.title}`);
    } catch (error) {
      console.error('‚ùå Erro ao processar sa√≠da de membro:', error.message);
    }
  }
  
  async handleMessage(msg) {
    try {
      // Registra intera√ß√£o do usu√°rio para sistema de DM
      if (msg.from && msg.from.id && !msg.from.is_bot) {
        await this.autoPostManager.registerUserInteraction(
          msg.from.id, 
          'message', 
          msg.chat.id
        );
      }
      
      // Capturar mensagens de grupos para identificar membros ativos
      if (msg.chat.type === 'group' || msg.chat.type === 'supergroup') {
        const groupId = msg.chat.id.toString();
        const userId = msg.from.id.toString();
        const groupName = msg.chat.title || 'Grupo sem nome';
        
        // Salvar/atualizar informa√ß√µes do grupo
        await this.groupManager.saveGroup({
          telegram_id: groupId,
          title: groupName,
          type: msg.chat.type,
          member_count: await this.getChatMemberCount(groupId)
        });
        
        // Salvar/atualizar membro se n√£o for bot
        if (!msg.from.is_bot) {
          await this.groupManager.saveMember({
            user_id: userId,
            group_id: groupId,
            username: msg.from.username,
            first_name: msg.from.first_name,
            last_name: msg.from.last_name,
            is_active: true
          });
        }
      }
    } catch (error) {
      console.error('‚ùå Erro ao processar mensagem:', error.message);
    }
  }
  
  async getChatMemberCount(chatId) {
    try {
      const count = await this.bot.getChatMemberCount(chatId);
      return count;
    } catch (error) {
      console.error('‚ùå Erro ao obter contagem de membros:', error.message);
      return 0;
    }
  }
  
  // === M√âTODOS DE AUTO-POST ===
  
  initializeAutoPost() {
    try {
      this.autoPostManager.start();
      console.log('‚úÖ Sistema de auto-post inicializado');
    } catch (error) {
      console.error('‚ùå Erro ao inicializar auto-post:', error.message);
    }
  }
  
  async handleAutoPost(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const status = this.autoPostManager.getStatus();
      const stats = await this.autoPostManager.getStats();
      
      let response = `ü§ñ **Sistema de Auto-Post**\n\n`;
      response += `**üìä Status:**\n`;
      response += `‚Ä¢ Sistema: ${status.isRunning ? '‚úÖ Ativo' : '‚ùå Inativo'}\n`;
      response += `‚Ä¢ Grupos ativos: ${status.activeGroups}\n`;
      response += `‚Ä¢ Intera√ß√µes: ${status.userInteractions}\n`;
      response += `‚Ä¢ √öltima atualiza√ß√£o: ${moment(status.lastUpdate).format('DD/MM HH:mm')}\n\n`;
      
      response += `**üìà Estat√≠sticas:**\n`;
      response += `‚Ä¢ Total de posts: ${stats.totalPosts || 0}\n`;
      response += `‚Ä¢ Total de DMs: ${stats.totalDMs || 0}\n`;
      response += `‚Ä¢ √öltimo post: ${stats.lastPost ? moment(stats.lastPost).format('DD/MM HH:mm') : 'Nunca'}\n`;
      response += `‚Ä¢ √öltimo DM: ${stats.lastDM ? moment(stats.lastDM).format('DD/MM HH:mm') : 'Nunca'}\n\n`;
      
      response += `**üéØ Comandos:**\n`;
      response += `‚Ä¢ \`/startauto\` - Iniciar sistema\n`;
      response += `‚Ä¢ \`/stopauto\` - Parar sistema\n`;
      response += `‚Ä¢ \`/togglepost <grupo_id>\` - Ativar/desativar grupo\n`;
      response += `‚Ä¢ \`/dmstats\` - Estat√≠sticas de DM\n`;
      response += `‚Ä¢ \`/testai\` - Testar gera√ß√£o de conte√∫do`;
      
      await this.bot.sendMessage(msg.chat.id, response, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('Erro no comando autopost:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao buscar status: ${error.message}`);
    }
  }
  
  async handleStartAuto(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const result = await this.autoPostManager.start();
      
      if (result.success) {
        await this.bot.sendMessage(msg.chat.id, 
          `‚úÖ **Sistema de auto-post iniciado!**\n\n‚Ä¢ Grupos ativos: ${result.activeGroups}\n‚Ä¢ Pr√≥ximo post: ${result.nextPost}`);
      } else {
        await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao iniciar: ${result.error}`);
      }
    } catch (error) {
      console.error('Erro ao iniciar auto-post:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao iniciar sistema: ${error.message}`);
    }
  }
  
  async handleStopAuto(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const result = await this.autoPostManager.stop();
      
      if (result.success) {
        await this.bot.sendMessage(msg.chat.id, 
          `üõë **Sistema de auto-post parado!**\n\n‚Ä¢ Posts realizados hoje: ${result.postsToday}\n‚Ä¢ Sistema estava ativo por: ${result.uptime}`);
      } else {
        await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao parar: ${result.error}`);
      }
    } catch (error) {
      console.error('Erro ao parar auto-post:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao parar sistema: ${error.message}`);
    }
  }
  
  async handleTogglePost(msg, match) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    const groupId = match[1];
    
    try {
      const result = await this.autoPostManager.toggleGroup(groupId);
      
      if (result.success) {
        const status = result.enabled ? 'ativado' : 'desativado';
        await this.bot.sendMessage(msg.chat.id, 
          `‚úÖ **Auto-post ${status} para o grupo!**\n\n‚Ä¢ Grupo: ${groupId}\n‚Ä¢ Status: ${result.enabled ? '‚úÖ Ativo' : '‚ùå Inativo'}`);
      } else {
        await this.bot.sendMessage(msg.chat.id, `‚ùå Erro: ${result.error}`);
      }
    } catch (error) {
      console.error('Erro ao alternar grupo:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao alternar grupo: ${error.message}`);
    }
  }
  
  async handleDMStats(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const stats = await this.autoPostManager.getDMStats();
      
      let response = `üì± **Estat√≠sticas de DM**\n\n`;
      response += `**üìä Hoje:**\n`;
      response += `‚Ä¢ DMs enviadas: ${stats.today.sent}\n`;
      response += `‚Ä¢ Sucessos: ${stats.today.success}\n`;
      response += `‚Ä¢ Falhas: ${stats.today.failed}\n`;
      response += `‚Ä¢ Taxa de sucesso: ${stats.today.successRate}%\n\n`;
      
      response += `**üìà Esta semana:**\n`;
      response += `‚Ä¢ Total de DMs: ${stats.week.total}\n`;
      response += `‚Ä¢ M√©dia di√°ria: ${stats.week.dailyAverage}\n`;
      response += `‚Ä¢ Convers√µes: ${stats.week.conversions}\n\n`;
      
      response += `**üéØ Performance:**\n`;
      response += `‚Ä¢ Melhor dia: ${stats.performance.bestDay}\n`;
      response += `‚Ä¢ Melhor hor√°rio: ${stats.performance.bestHour}h\n`;
      response += `‚Ä¢ Taxa geral: ${stats.performance.overallRate}%`;
      
      await this.bot.sendMessage(msg.chat.id, response, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('Erro ao buscar stats de DM:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro ao buscar estat√≠sticas: ${error.message}`);
    }
  }
  
  async handleTestAI(msg) {
    if (!this.isAdmin(msg.from.id)) {
      await this.bot.sendMessage(msg.chat.id, '‚ùå Acesso negado.');
      return;
    }
    
    try {
      const loadingMsg = await this.bot.sendMessage(msg.chat.id, 'ü§ñ Testando gera√ß√£o de conte√∫do com IA...');
      
      const testContent = await this.geminiAI.generateContent({
        type: 'promotional',
        topic: 'teste do sistema',
        style: 'engaging'
      });
      
      let response = `ü§ñ **Teste de Gera√ß√£o de Conte√∫do**\n\n`;
      response += `**üìù Conte√∫do gerado:**\n${testContent.text}\n\n`;
      response += `**üìä Detalhes:**\n`;
      response += `‚Ä¢ Tipo: ${testContent.type}\n`;
      response += `‚Ä¢ Palavras: ${testContent.wordCount}\n`;
      response += `‚Ä¢ Tempo: ${testContent.generationTime}ms\n`;
      response += `‚Ä¢ Qualidade: ${testContent.quality}/10`;
      
      await this.bot.editMessageText(response, {
        chat_id: msg.chat.id,
        message_id: loadingMsg.message_id,
        parse_mode: 'Markdown'
      });
      
    } catch (error) {
      console.error('Erro no teste de IA:', error);
      await this.bot.sendMessage(msg.chat.id, `‚ùå Erro no teste: ${error.message}`);
    }
  }

  // Fun√ß√£o utilit√°ria para escapar caracteres especiais do Markdown
  escapeMarkdown(text) {
    if (!text || typeof text !== 'string') {
      return '';
    }
    // Escapa caracteres especiais do Markdown V2
    return text.replace(/([_*\[\]()~`>#+\-=|{}.!\\])/g, '\\$1');
  }

  // Para o bot
  stop() {
    if (this.autoPostManager) {
      this.autoPostManager.stop();
    }
    if (this.bot) {
      this.bot.stopPolling();
      console.log('üõë Bot Telegram parado');
    }
  }
}

module.exports = TelegramSubscriptionBot;
